# Взаимодействие программы на Си со своим окружением

Язык Си используется для разработки программного обеспечения,
работающего на широчайшем диапазоне оборудования под управлением
различных операционных сред. Выделяют два типа среды,
в которой может выполняться программа на Си:

* conforming - программа выполняется под управлением какой-либо операционной
среды, которая поддерживает все обязательные требования стандарта языка.
В такой операционной среде поддерживаются файлы и заголовочный
файл `<stdio.h>`, динамическая память и `<stdlib.h>`, аргументы
командной строки и т.д. Conforming окружение - это обычная среда,
доступная при разработке на Си под Linux, Windows, MacOS, FreeRTOS или другой
операционной системой.

* freestanding - программа выполняется "сама по себе", например,
это ядро операционной системы, или управляющая программа,
работающая на контроллере STM32. В такой операционной среде
отсутствуют или ограничены возможности ввода вывода, динамическая память,
аргументы командной строки. Гарантируется минимальное
количество функций стандартной библиотеки (функций типа `memcpy`
и аналогичных).

Сначала мы рассмотрим взаимодействие программы со своим окружением
в conforming окружении.

## Стандартные потоки ввода-вывода

Работающей программе изначально доступны три высокоуровневых
дескриптора потока (`FILE *`): `stdin`, `stdout`, `stderr`.

Стандартный поток ввода (`stdin`) используется для ввода
данных в программу. Если вводятся последовательность
данных заранее неизвестной длины, то данные должны
считываться до "признака конца ввода" или "признака конца файла".

Стандартный поток вывода используется для вывода нормального результата
работы программы, вычисленного на основе входных данных.
Если программа не является программой-фильтром, обрабатывающим
поток символов на стандартном потоке ввода,
то хорошим стилем при выводе результата является добавления
символа перевода конца строки `'\n'` после вывода результата.

Например, так плохо:

```c
    printf("%d", result);
```

А вот так гораздо лучше:

```c
    printf("%d\n", result);
```

Стандартный поток ошибок используется для вывода какой-либо
информации, назначение которой &mdash; помочь человеку понять
причину, по которой программа не может обработать входные данные.
Обычно &mdash; это сообщения об ошибках разного рода.
Фиксированного стандарта на сообщение об ошибках нет,
но считается хорошим стилем вывести название самой программы,
затем строку, характеризующую ошибки, а затем указать объект,
из-за которого произошла ошибка. Сообщение об ошибках
должно завершаться символом перехода на новую строку
`'\n'`.

Вот так совсем плохо:

```c
    printf("error!");
```

нельзя выводить сообщение об ошибке на `stdout`, непонятно какая ошибка
в какой программе произошла и почему.

А вот так хорошо:

```c
    fprintf(stderr, "mysupercalc: division by zero\n");
```

## Код завершения программы

Вывод сообщения на стандартный поток ошибок имеет неформальный
характер и в первую очередь призван помочь человеку обнаружить
и устранить ошибку. Чтобы формально сообщить операционной среде
об успешности исполнения программы используются коды завершения.

Код завершения &mdash; это число в диапазоне `[0,255]`.
Значение `0` означает, что программа выполнилась "успешно".
Понятие успешности может варьироваться, но обычно это означает,
что программа смогла обработать все переданные ей входные данные
и для всех данных был получен результат. Любое ненулевое
значение означает, что при выполнении программы произошла
какая-либо ошибка. Какие ненулевые значения означают какие ситуации
в работе программы оставляется на откуп разработчика программы.

Код завершения указывается в качестве аргумента в функции `exit`, `_exit`
или `_Exit` стандартной библиотеки. В функции `main` код завершения
указывается в операторе `return`.

Обратите внимание, что функция `main` в программе является
особенной. Она должна быть объявлена как функция, возвращающая
значение типа `int`, но в ней может отсутствовать явный оператор
`return` со значением. В этом случае подразумевается
`return 0`. Например,

```c
int main(void)
{
    printf("true");
}
```

эта программа всегда будет завершаться с кодом завершения 0.

Кроме того, обратите внимание, что код завершение &mdash; это
положительное число. Поэтому плохим стилем является следующее:

```c
    if (failed) {
        exit(-1);
    }
```

В этом примере в качестве кода завершения будут взяты младшие 8 бит числа
`-1`, поэтому фактический код завершения будет `255`. Лучше в качестве
кода завершения использовать `1`.

Код завершения является характеристикой работы программы,
если программа завершилась "добровольно", то есть в результате
завершения функции `main`, либо в результате вызова функций
`exit` и аналогичных.

Но операционная система имеет средства завершать работу программы
принудительно, если с точки зрения операционной системы
в работе программы что-то пошло не так. В этом случае
в терминологии POSIX-ориентированных операционных систем говорят,
что программа завершилась из-за сигнала. Номер сигнала
означает более конкретную причину аварийного завершения программы.
Например, если программа попыталась выполнить
операцию целочисленного деления на 0, она завершится из-за сигнала 8,
а если программа попыталась выполнить некорректную операцию
с памятью &mdash; из-за сигнала 11. Сигналы, их основные типы,
назначения и способы обработки будут рассмотрены позднее в курсе.

Когда вы работаете в командной строке shell, код завершения
программы можно посмотреть с помощью переменной `$?`.
Например,

```
[ejudge@ejudge ~]$ ls -l /zzz
ls: cannot access '/zzz': No such file or directory
[ejudge@ejudge ~]$ echo $?
2
[ejudge@ejudge ~]$ 
```

В этом примере код завершения программы `ls` равен 2.

Если программа завершилась из-за сигнала, то в оболочке shell
переменная `$?` будет равна `128+n`, где `n` &mdash; номер сигнала.

```
[ejudge@ejudge ~]$ ./prog
Segmentation fault (core dumped)
[ejudge@ejudge ~]$ echo $?
139
[ejudge@ejudge ~]$ 
```

## Аргументы командной строки

В примере выше вызывалась команда `ls` и прямо в строке команды
ей передавались дополнительные данные: `ls -l /zzz`.
Такой способ передачи данных в программу называется
передачей аргументов командной строки.
Перед передачей аргументов в программу командная строка
обрабатывается оболочкой shell, которая выделяет из командной строки
специальные конструкции (например, перенаправления) и формирует
массив аргументов командной строки, так, что программа при запуске
получает не одну командную строку, введенную пользователем,
а уже предобработанный массив аргументов.

Для обработки аргументов командной строки функция `main`
должна быть описана следующим образом:

```c
int main(int argc, char *argv[])
{
}
```

Естественно, имена параметров `argc` и `argv` могут быть
произвольными, но сложилась традиция называть их именно так.

Параметр `argc` &mdash; это количество аргументов командной строки,
а параметр `argv` &mdash; это указатель на массив указателей
на строки &mdash; собственно аргументы командной строки.

Простая программа распечатывает все аргументы командной строки.

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	for (int i = 0; i < argc; ++i) {
		printf("%d: %s\n", i, argv[i]);
	}
}
```

Если запустить программу с аргументами:

```
./prog a b c d
```

на стандартный поток вывода будет напечатано

```
0: ./prog
1: a
2: b
3: c
4: d
```

Значение `argv[0]` &mdash; это имя программы. Интерпретатор
shell передает в `argv[0]` ровно то имя запускаемой программы,
что было указано в командной строке. Но, вообще говоря,
возможно в качестве `argv[0]` передавать произвольную строку,
никак не связанную с именем запускаемой программы.

Гарантируется, что значение `argv[argc]` всегда равно `NULL`,
и среди аргументов командной строки отсутствует указатель `NULL`.
В этом смысле параметр `argc` избыточен, так как количество
аргументов командной строки можно определять и по самому
массиву аргументов командной строки, просканировав его до
первого указателя `NULL`. Так, системный вызов `execve`,
который мы будем рассматривать далее в курсе,
принимает только параметр `argv`, без `argc`.

Повторим еще раз, что все элементы массива аргументов командной
строки &mdash; это строки. Если в аргументе командной строки
передаётся число, то перед использованием число должно быть
преобразовано из строкового формата во внутреннее представление,
что мы будем обсуждать позднее.

## Переменные окружения

Когда пользователь входит в систему любым способом:
в оконную среду, через ssh или из текстовой консоли,
создаётся сессия работы пользователя. Настройки сессий
могут отличаться друг от друга. Чтобы хранить и настройки
сессий, и настройки режимов работы, задаваемые пользователем,
используются "переменные окружения". Переменные окружения
представляют собой множество поименованных строк. В отличие
от параметров командной строки, которые нужно указывать
в командной строке запускаемой программы, переменные
окружения передаются в запускаемую программу неявно,
то есть каждая запускаемая программа при запуске
получает копию всех переменных окружения, которые
были установлены в момент запуска.

Посмотреть текущие переменные окружения можно с помощью команды
`env`, примерный вывод которой показан ниже.

```
[cher@fedora ~]$ env
SHELL=/bin/bash
IMSETTINGS_INTEGRATE_DESKTOP=yes
COLORTERM=truecolor
HISTSIZE=1000
HOSTNAME=fedora
DESKTOP_SESSION=xfce
EDITOR=/usr/bin/nano
PWD=/home/cher
LOGNAME=cher
XDG_SESSION_DESKTOP=xfce
XDG_SESSION_TYPE=x11
GDM_LANG=en_US.utf8
HOME=/home/cher
LANG=en_US.utf8
XDG_CURRENT_DESKTOP=XFCE
TERM=xterm-256color
USER=cher
SHLVL=1
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin
[cher@fedora ~]$ 
```

На стандартный поток вывода будут напечатаны текущие
переменные окружения.

Некоторые переменные окружения и их назначение перечислены ниже.

`PATH` содержит список путей к каталогам с исполняемыми файлами.
Пути в каталоге разделяются символом `':'`. Эта переменная окружения
используется для определения пути в файловой системе, по которому
находится программа для запуска. Например, для исполнения
команды `ls -l /usr` необходимо определить полный путь,
по которому расположен исполняемый файл `ls`. Оболочка
shell будет последовательно пробовать файлы `/usr/local/bin/ls`,
`/usr/bin/ls`, `/bin/ls`, `/usr/local/sbin/ls`, `/usr/sbin/ls`.
Первый найденный исполняемый файл (скорее всего это будет `/usr/bin/ls`)
и будет полным путем к запускаемому исполняемому файлу.

Обратите внимание, что путь `.` (текущий каталог) обычно не включается
в список каталогов в переменной окружения `PATH` по соображениям
безопасности. Поэтому, чтобы запустить программу из текущего
каталога необходимо явно указывать текущий каталог, например `./prog`.

`LANG` задает язык взаимодействия с пользователем и
кодировку текста для программ, взаимодействующих
с пользователем. Если переменная `LANG` равна `en_US.utf8`,
язык взаимодействия &mdash; американский английский (`en_US`),
а кодировка текста &mdash; UTF-8.

Сравните:

```
[cher@fedora ~]$ date
Fri Sep 10 09:48:07 AM MSK 2021
[cher@fedora ~]$ LANG=ru_RU.UTF8 date
Пт 10 сен 2021 09:48:14 MSK
[cher@fedora ~]$ LANG=fr_FR.UTF8 date
ven. 10 sept. 2021 09:51:22 MSK
[cher@fedora ~]$
```

Запись `LANG=fr_FR.UTF8 date` означает, что переменная окружения
`LANG` модифицируется только для одного запуска программы `date`.
Текущее окружение shell не изменяется.

### Передача переменных окружения в программу

В POSIX-ориентированных операционных системах функция `main`
может принимать третий параметр.

```c
int main(int argc, char *argv[], char *envp[])
{
}
```

`envp` &mdash; это указатель на начало массива указателей на строки с переменными
окружения. Каждая строка имеет вид `NAME=VALUE` (то есть как
в выводе команды `env`). Массив строк заканчивается указателем `NULL`,
как и массив `argv`.

Следующая программа выведет все аргументы командной строки
и все переменные окружения, переданные в программу.

```c
#include <stdio.h>

int main(int argc, char *argv[], char *envp[])
{
	for (int i = 0; i < argc; ++i) {
		printf("%d: %s\n", i, argv[i]);
	}
	for (int i = 0; envp[i]; ++i) {
		printf("%s\n", envp[i]);
	}
}
```

Но важно, что указатель `envp` содержит адрес начала массива
указателей на строки переменных окружения только в момент
начала работы программы. Если модифицировать переменные
окружения с помощью функций стандартной библиотеки `setenv`,
`putenv`, значение, переданное в параметре `envp`,
скорее всего, станет неактуальным.

В любой момент работы программы текущий адрес начала массива
указателей на строки переменных окружения находится в
глобальной переменной `environ`.

```c
extern char **environ;
```

Чтобы использовать глобальную переменную `environ` нужно
её явно определить как внешнюю переменную как описано выше.
Почему-то её определение не включено ни в один заголовочный файл.

Следующая программа выведет на стандартный поток вывода
все свои переменные окружения.

```c
#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
	for (int i = 0; environ[i]; ++i) {
		printf("%s\n", environ[i]);
	}
}
```

Для получения значения одной конкретной переменной
окружения удобнее использовать стандартную функцию `getenv`.

```
#include <stdlib.h>

char *getenv(const char *name);
```

В аргументе `name` передается имя переменной окружения.
Функция возвращает указатель на строку &mdash; значение переменной
окружения, либо `NULL`, если переменная с таким именем отсутствует
среди переменных окружения. Это демонстрирует программа ниже.

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    if (argv[1]) {
        const char *s = getenv(argv[1]);
        if (s) {
            printf("%s\n", s);
        } else {
            fprintf(stderr, "%s: variable '%s' is undefined\n", argv[0], argv[1]);
            return 1;
        }
    }
}
```

Примеры запуска приведены ниже.

```
[cher@fedora ~]$ ./prog PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin
[cher@fedora ~]$ ./prog Z
./prog: variable 'Z' is undefined
[cher@fedora ~]$ 
```
