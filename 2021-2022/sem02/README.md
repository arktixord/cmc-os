# Поведение программы на Си при выполнении

Обычно, если программа написана правильно, для любых входных
данных, удовлетворяющих ограничениям на входные данные для программы,
и программа работает детерминированно,
мы знаем, какой будет результат вычислений. Например,

```c
    int a = 1, b = 2;
    int c = a + b;
```

понятно, что значение `c` будет равно `3`.
Однако, универсальность этого знания требует уточнения.
Верно ли это утверждение для любого транслятора языка Си,
или возможны варианты? Мы предполагаем, что сам по себе
транслятор Си не содержит ошибок.

Язык программирования может быть описан по-разному. От совсем формального
описания на каком либо формальном языке, например, языке спецификаций,
или языке программирования, с одной стороны, до популярного изложения
в учебнике. Стандарты языков программирования обычно не ставят цель
описать язык программирования полностью формально, но должны
описывать язык настолько полно, чтобы, например, любой человек
мог реализовать транслятор языка и при этом не возникало неоднозначностей.

На этом пути возникает несколько проблем.

* Во-первых, стандарт языка может разрабатываться тогда, когда язык программирования
уже распространен, и существует несколько реализаций языка, немного отличающихся друг от друга.
Для каждой реализации языка уже написано большое количество программного обеспечения,
которое должно продолжать работать и при переходе к стандартизированной реализации языка. Это &mdash;
проблема обратной совместимости.

* Во-вторых, полностью строго фиксированное определение языка может противоречить какой-либо из целей,
которые стремится достичь язык. Например, для языка Си, одним из целей которого всегда было
получение максимальной производительности программ, строгое фиксирование её работы для любого
процессора может привести к тому, что для каких-то процессоров потребуется дополнительная
программная реализация в ущерб производительности. Это &mdash; проблема производительности.

Стандарт языка Си стремится описать язык строго и однозначно, там где это не противоречит
требованиям обратной совместимости или производительности. А в этих случаях стандарт предоставляет
некоторую свободу существующим реализациям и разработчикам компиляторов на разные аппаратные платформы.

## Implementation-Defined Behavior

Это выражается в понятии "Implementation-Defined Behavior" (поведение, зависящее от реализации).
Implementation-defined behavior (IDB) отмечает те аспекты описания поведения программы в которых:
* стандарт предлагает несколько возможных вариантов реализации;
* разработчики транслятора должны выбрать одну из предложенных опций и строго следовать ей;
* выбор разработчиков должен быть задокументирован.

Например, соответствующий раздел документации компилятора gcc разположен
[здесь](https://gcc.gnu.org/onlinedocs/gcc/C-Implementation.html).

Пожалуй, первый пример, который возникает при рассмотрении этого понятия, это размеры
целых типов. На разных платформах (то есть разных комбинациях процессорной архитектуры
и операционной системы) из соображений эффективности выбраны разные размеры целых типов.
Стандарт Си оговаривает ограничения на размеры, например, что размер типа `int`
не менее 16 бит, размер типа `long` не меньше типа `int` и т. п.
Точные размеры целых типов уточняются для каждого компилятора в документации.

Битность типа `char` &mdash; это второй пример IDB. Стандарт Си требует, чтобы тип `char`
содержал не менее 8 бит, но встречаются процессоры (обычно DSP - digital signal processors,
на которых `char` имеет размер 16, 24 или даже 32 бита.

Вообще, даже битовое представление отрицательных целых чисел является IDB. Стандарт предлагает
три варианта: дополнительный код (twos' complement), обратный код (ones' complement) и прямой код
(sign-magnitude). Другое дело, что сейчас найти процессор, который бы представлял отрицательные числа
не в дополнительном коде, практически невозможно, хотя, говорят,
что [такие архитектуры даже развиваются](https://superuser.com/questions/1137182/is-there-any-existing-cpu-implementation-which-uses-ones-complement).
Компилятор gcc не поддерживает и не собирается поддерживать платформы не с дополнительным кодом.
Ожидается, что в следующей версии стандартов Си и Си++ будет зафиксировано представление
отрицательных чисел в дополнительном коде.

Более специфичные стандарты, например, стандарт POSIX на операционные системы, требует, чтобы в типе `char` было 8 бит,
в типе `short` &mdash; 16 бит, а в типе `int` &mdash; 32 бита. Поэтому при разработке программ для
POSIX-ориентированных операционных систем (и в Linux, и во FreeBSD, и в MacOS/iOS) можно предполагать, что в типе `char`
8 бит, а в типе `int` &mdash; 32 бита.

Более важно практически, что знаковость типа `char`, то есть является ли тип `char` по диапазону представимых значений
совпадающим с типом `signed char`, либо совпадающим с типом `unsigned char`, &mdash; это тоже IDB. На некоторых платформах,
к которым относятся и платформы на процессорах семейства x86 и x86_64, тип `char` традиционно знаковый, то есть
диапазон представимых значений типа равен `[-128; 127]`. На других платформах, к которым относятся и ARM,
тип `char` беззнаковый с диапазоном представимых значений `[0, 255]`. Некорректное предположение, что переменная типа `char`
всегда неотрицательная, или, с другой стороны, что в переменной типа `char` можно хранить небольшие отрицательные значения &mdash;
это типичный источник ошибок в программах на Си и Си++.

Также в зависимости от платформы может варьироваться байтовое представление целых целых чисел. Типичные варианты &mdash;
это [Little-Endian и Big-Endian](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2).
Большинство произведенных в мире процессоров в настоящее время хранят целые числа в порядке байт Little-Endian. Порядок байт
Big-Endian используется, например, в процессорах MIPS, работающих в бытовых роутерах. Big-Endian порядок байт
используется в служебных данных (т. н. заголовках пакетов) в сетях TCP/IP, о чем мы будем говорить позднее.

Несколько других случаем IDB мы рассмотрим в разделе, посвященном целочисленной арифметике.

## Unspecified Behavior

Implementation-defined behavior позволяет уточнить поведение программы на конкретной программно-аппаратной платформе.
Программисту может быть важно знать implementation-defined особенности компилятора, чтобы писать максимально эффективный
код.

С другой стороны, есть такие детали выполнения программы, которые несущественны с точки зрения ее результата,
точнее, которые в стандарте языка сочтены несущественными. И в этом случае компилятору дана полная свобода
компилировать программу так, чтобы получить наиболее эффективный результат. В разных местах компилируемой
программы компилятор может обрабатывать такие ситуации по-разному.

Например, аргументы бинарной арифметической операции могут вычисляться в произвольном порядке.
Если дан фрагмент:

```c
    int res = f() + g();
```

В одном месте программы может сначала вычисляться `f()`, затем `g()`, а в другом месте программы &mdash; наоборот.

Аналогично при вычислении аргументов функции:

```c
    f(g(), h());
```

Вызовы `g()` и `h()` могут выполняться в любом порядке.

Если функции `g()` и `h()` имеют наблюдаемый побочный эффект, программа может давать разный наблюдаемый побочный
эффект на разных платформах, при разных настройках оптимизации и т. п.

Такие аспекты поведения программы называются "unspecified behavior". Реализация транслятора языка не обязана
документировать, как обрабатываются ситуации "unspecified behavior", транслятор может обрабатывать
unspecified behavior по-разному в разных местах программы. Понятие "unspecified behavior" введено для того,
чтобы не конфликтовать с существующими реализациями языка, и для того, чтобы давать компилятору больший
простор для оптимизации программы.

Если наблюдаемое поведение программы не зависит от unspecified behavior, может зависить от implementation-defined
behavior, а в остальном строго определено в терминах стандарта, такая программа является корректной
(well-behaving). Она будет переносимой на платформы с совпадающими implementation-defined деталями.

## Undefined behavior

При выполнении программы может возникнуть ситуация, выходящая за пределы, определенные стандартом языка для
well-behaving программы. Например, программа пытается выполнить целочисленное деление на 0 или
разыменование указателя NULL. Можно было бы сказать, что при выполнении программы возникла ошибка,
но вместо этого стандарт использует термин "undefined behavior" (UB). Другими словами,
попытка выполнения операции целочисленного деления на 0 &mdash; это undefined behavior (UB).

Undefined behavior с точки зрения стандарта Си &mdash; это ситуация, после возникновения которой
в программе все дальнейшее поведение программы неопределено и не описывается стандартом языка.
То есть выполняющаяся программа вольна вести себя как угодно: вывести сообщение об ошибке,
аварийно завершить программу, а может даже и удалить все файлы на диске! Сначала это может
вызвать недоумение, но на самом деле это разумно, хотя, отчасти, вынуждено.

Во-первых, ситуации undefined behavior не могут быть гарантированно обнаружены при компиляции программы.
Например, возникнет ли в программе целочисленное деление на 0 зависит от значеня делителя,
которое может быть неизвестно на этапе компиляции, так как зависит от входных данных.

Во-вторых, гарантированно обнаружить undefined behavior при выполнении программы может быть
слишком дорого с точки зрения производительности. Например, чтобы обнаружить выход за пределы
массива в операции индексации `a[i]`, требуется в генерируемый код вставлять проверки
допустимого диапазона индексов. Конечно, часть таких проверок может быть устранена
при оптимизации программы, но большая часть все равно останется и существенно
повлияет на скорость исполнения.

В-третьих, язык Си не ставит целью скрывать особенности работы различных процессоров, а наоборот,
инкорпорирует их в язык в виде implementation-defined behavior. Это нужно, чтобы конструкции языка
отображались в инструкции процессора "напрямую", без дополнительных прослоек совместимости.
Но если поведение корректных программ, отличающееся на разных процессорах, надо
стандартизировать в виде implementation-defined behavior безусловно, то необходимость стандартизации
поведения некорректных программ выглядит излишне. Это только увеличит объем стандартизации и наложит
излишние требования на разработчиков компиляторов и процессоров.

Разные процессоры по разному обрабатывают ошибки, возникающие при выполнении инструкций.
Например, на процессорах семейства x86 инструкция целочисленного деления при делении на 0 (`div` или `idiv`)
генерирует аппаратное исключение `#DE`. Но на процессорах ARM в этом случае просто вырабатывается результат 0.

Вот поэтому стандарты Си и Си++ не определяют поведение программы в случае ошибки, а постулируют,
что после undefined behavior "нормальность" программы заканчивается и может быть что угодно.
На практике в случае undefined behavior может происходить аварийное завершение программы
(как в случае разыменования указателя NULL программа скорее всего завершится с Segmentation Fault),
либо программа продолжит работать с каким-то произвольным результатом операции и может
сломаться где-то далеко позже момента UB (как в случае двойного освобождения динамической
памяти с помощью `free`).

Важным шагом при компиляции программы является оптимизация сгенерированной машинной программы.
Компиляторы могут выполнять самые различные преобразования кода при условии, что у оптимизированной
программы сохранится наблюдаемое поведение при последовательном выполнении в один поток.
Компилятор Си может предполагать, что инструкции программы будут выполняться строго последовательно
и не прерываясь, то есть в поток исполняющихся инструкций не вклиниваются, например,
прерывания процессора.

Кроме того, поскольку в случае undefined behavior дальнейшее поведение программы неопределено,
то программа может доработать до конца и выработать результат только в случае, когда
при выполнении не возник undefined behavior. Компилировать программу, которая не доработает
до конца, бессмысленно, поэтому <b>компиляторы Си и Си++ могут предполагать, что
при выполнии программы undefined behavior не возникает</b>. Компиляторы имеет право
оптимизировать программу, исходя из этого предположения. Современные компиляторы
стараются оптимизировать программу очень "агрессивно", поэтому предположение
о невозможности undefined behavior может существенно изменить сгенерированный код.

Например, в следующем фрагменте программы

```c
int f(int z);
int func(const char *ptr)
{
    char c = *ptr;
    if (ptr == 0) {
        return -1;
    }
    return f(c);
}
```

в первой строке программы разыменовывается указатель `ptr`. Разыменование указателя `NULL` &mdash; UB,
но компилятор предполагает, что в программе не возникает UB, отсюда следует, что `ptr != NULL`,
поэтому компилятор удалит проверку в `if` и оператор `return`.

Если скомпилировать этот фрагмент с опциями компилятора `-m32 -O0` (то есть генерировать 32-битный код
без оптимизаций), то мы получим следующий ассемблер.

```
func:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $24, %esp
    movl    8(%ebp), %eax
    movzbl  (%eax), %eax
    movb    %al, -9(%ebp)
    cmpl    $0, 8(%ebp)        // проверка на 0
    jne .L2
    movl    $-1, %eax          // результат функции -1
    jmp .L3
.L2:
    movsbl  -9(%ebp), %eax
    subl    $12, %esp
    pushl   %eax
    call    f
    addl    $16, %esp
.L3:
    leave
    ret
```

видно, что проверка указателя `ptr` и возврат значения `-1` на месте.
Но если скомпилировать этот фрагмент с опциями `-m32 -O2`, то есть включить оптимизации, то получим

```
func:
    movl    4(%esp), %eax
    movsbl  (%eax), %eax
    movl    %eax, 4(%esp)
    jmp f
```

то есть сразу выполняется переход на функцию `f` с передачей ей значения `c`.

Поэтому, в общем, при undefined behavior может быть отформатирован диск &mdash;
это не преувеличение. Подробнее об этом можно прочитать [здесь](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html).

# Операции со значениями целых типов

В языке Си определены как знаковые, так и беззнаковые типы различной битности. В этом разделе мы рассмотрим операции со
знаковыми и беззнаковыми типами, отмечая наличие implementation-defined и undefined behavior.

## Операции с беззнаковыми числами

Операции с беззнаковыми числами c N битами определены по модулю 2^N. То есть в качестве результата всегда берутся N младших бит.
Такое поведение гарантируется стандартом. То есть в языке Си беззнаковая арифметика определена строго.

Например,
```c
    UINT_MAX + 1 == 0
    0 - 1U == UINT_MAX
```

При преобразовании беззнакового числа меньшей битности к беззнаковому числу большей битности старшие биты
заполняются нулями.

## Преобразование между знаковыми и беззнаковыми числами

* преобразование между беззнаковыми и знаковыми числами одинаковой битности выполняется побитовым копированием

* при преобразовании знакового или беззнакового числа большей битности к знаковому числу меньшей битности,
если исходное число не представимо точно меньшим числом бит, это implementation-defined behavior. Возможны два
варианта: либо отбросить "лишние" старшие биты, либо аварийно завершить программу. В большинстве реализаций
(на самом деле на всех популярных процессорах общего назначения) старшие биты отбрасываются.

* беззнаковое число меньшей битности преобразовывается в знаковое число большей битности дополнением
нужным количеством нулевых бит в старших разрядах.

* знаковое число меньшей битности преобразовывается в беззнаковое число большей битности.
Правила преобразования формилируются так:

> the  value  is  converted  by  repeatedly  adding  or subtracting
> one  more  than  the  maximum  value  that  can  be  represented  in  the  new type
> until the value is in the range of the new type.

То есть положительные числа дополняются слева нулевыми битами, а отрицательные - единичными битами,
то есть происходит расширение знака.

## Операции со знаковыми числами

В отличие от беззнаковой арифметики знаковая арифметика определена намного хуже.
Во всех примерах дальше мы будем предполагать 32-битный int и представление чисел в дополнительном коде.

* если результат знаковой арифметической операции непредставим в знаковом типе результата, это undefined behavior.
Например,

```
2000000000 + 2000000000    // UB!
2000000000 + 2000000000U == 4000000000U   // это беззнаковая операция!

signed char a = 100, b = 100, c = a + b;  // UB нет, c == -56
```

* сдвиг отрицательного числа вправо &mdash; implementation-defined behavior. Реализация в языке Си
зависит от того, как инструкция сдвига реализована в процессоре. Типичный вариант, реализованный
на большинстве процессоров, в частности, на x86 и ARM &mdash; знаковый бит остается на месте.

* сдвиг отрицательного числа влево &mdash; undefined behavior. То есть в терминах языка Си
знаковый сдвиг влево определен только для неотрицательных чисел. Это представляется немного странным,
по идее, можно было бы определить эту операцию как implementation-defined с undefined только при переполнении.
Но согласно текущей версии стандарта Си отрицательные числа сдвигать влево нельзя. Обратите внимание,
что знаковый сдвиг влево даст UB и тогда, когда старший значащий бит числа переходит в знаковый бит,
то есть происходит знаковое переполнение.

* и знаковая, и беззнаковая операция сдвига на число бит, большее или равное размера типа &mdash; undefined behavior.

* сдвиг на отрицательную величину &mdash; undefined behavior.

Обратите внимание, что undefined behavior при знаковых переполнениях &mdash; это особенность Си/Си++.
Соответствующие инструкции процессора (`add`, `sal`, `sar` и т.п.) не содержат никакого UB
и определены для любых значений аргумента.

Но почему переполнение при знаковых операциях в стандарте Си приводит к undefined behavior? Если
на процессорах соответствующие операции определены для любых значений аргументов, то почему это
не implementation-defined behavior? В целом, концепция undefined behavior позволяет компилятору
оптимизировать программу лучше, но за счет того, что ответственность за проверку попадания
в ошибочную ситуацию перекладывается на программиста.

Например, если `x` переменная типа `int`, выражение `x * 2 / 2` может быть оптимизировано в `x`,
так как компилятор имеет право предполагать, что знаковое переполнение никогда не произойдет.
А вот если переменная `z` имеет тип `unsigned`, то выражение `z * 2 / 2` оптимизировать нельзя,
так как в случае, когда у переменной `z` установлен старший бит, он будет очищен.
Пример может показаться странным, но такие выражения могут появляться в результате макрорасширений,
подстановок `inline` функций и т. п.

Другой пример, это цикл

```c
for (int i = 0; i <= n; ++i) {...}
```

компилятор может предполагать, что этот цикл конечен и будет всегда иметь `n + 1` итерацию.

Но для цикла
```c
for (unsigned i = 0; i <= n; ++i) { ... }
```

такого предположения делать нельзя, так как при `n == UINT_MAX` это будет бесконечный цикл.

В итоге, компилятор языка Си может оптимизировать программы гораздо лучше, чем, например,
в языке Java, в котором знаковая целочисленная арифметика определена
для всех значений как модульная арифметика.

## Контроль переполнения при выполнении арифметических операций

Итак, переполнение при выполнении беззнаковой операции дает младшие биты результата,
а переполнение при выполнении знаковой операции дает undefined behavior.

Но в реальных программах очень важно контролировать операции над данными, которые
поступили в программу из внешнего источника, например, введены пользователем.

Простой пример:
```c

   int n, m;
   scanf("%d%d", &n, &m);
   int *array = malloc(n * m * sizeof(*array));
```

Пользователь может ввести такие значения `n` и `m`, что их произведение
будет больше значения, представимого типом `int`. Если бы переполнения не было,
функция `malloc` нормально вернула бы `NULL` из-за слишком большого объема запрошенной
памяти. Но в результате переполнения результатом произведения может быть
и небольшое число, и `malloc` успешно выделит динамическую память, но намного меньшего размера,
чем требуется. Последующее заполнение массива может привести к выходу за пределы
выделенной памяти. Ошибки такого рода регулярно обнаруживаются во всех программах от веб-браузеров
до ядер операционных систем. Использование таких ошибок злоумышленником может
приводить и к взлому системы.

Хотя большинство процессорных архитектур позволяют проверять на переполнение очень эффективно,
например, на x86 проверяя значение флагов CF или OF, стандарт языка Си таких возможностей не предоставляет,
и приходится городить не очень эффективные и громоздкие конструкции.
Но если используется компилятор gcc или clang, который старается быть совместимым с gcc,
то можно использовать расширения языка, предоставляемые gcc, так называемые
[встроенные функции](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html).

Три функции позволяют проверять на переполнение операции сложения, вычитания и умножения.

```c
_Bool  __builtin_add_overflow(TYPE a, TYPE b, TYPE *res);
_Bool  __builtin_sub_overflow(TYPE a, TYPE b, TYPE *res);
_Bool  __builtin_mul_overflow(TYPE a, TYPE b, TYPE *res);
```

Здесь `TYPE` может быть любым типом из int, unsigned, long, unsigned long, long long, unsigned long long.
Параметры `a` и `b` передаются по значению, а третьим параметром надо передать указатель, по которому
будет записан результат операции. В качестве результата операции всегда возвращаются младшие биты результата.
Функция возвращает 0, если при выполнении операции переполнения не возникло, и 1, если переполнение возникло.
Никакого undefined behavior при вызове этой функции никогда не возникает.

Конечно же, хотя в программе на Си это выглядит как вызов функции с передачей ей параметров
и с сохранением результата по указателю, на самом деле сгенерированный компилятором код
будет настолько эффективен, насколько можно. Будет сгенерирована инструкция процессора,
например, инструкция сложения `add` и инструкция условного перехода `jo`.

С использованием таких __builtin функций фрагмент кода выше может быть переписан следующим образом.

```c

   int n, m;
   scanf("%d%d", &n, &m);
   int z;
   int *array;
   if (__builtin_mul_overflow(n, m, &z) || __builtin_mul_overflow(z, sizeof(*array), &z)) {
       fprintf(stderr, "data is too big\n");
       exit(1);
   }
   array = malloc(z);
```

Выглядит это не очень, но задачу решает.

# Контроль ошибок в программе

Мы будем говорить не об ошибках программиста в исходном коде программы, а об ошибках
как о нештатных ситуациях при работе программы, вызванных внешними по отношению к программе факторами.

Очень условно, нештатные ситуации можно разделить на несколько категорий.
* некорректный пользовательский ввод;
* ошибки взаимодействия;
* ошибки, связанные с использованием общих ресурсов системы (например, файлов в файловой системе);
* аппаратные ошибки;
* ошибки нехватки ресурсов.

При возникновении нештатной ситуации программа должна как-то о ней сообщить (от вывода на стандартный поток
ошибок до записи в специальный лог-файл) и восстановиться в целостное состояние, не допустив при этом
утечек ресурсов.

Некорректный пользовательский ввод &mdash; это, пожалуй, самый частый и самый опасный источник нештатных ситуаций.
Пример некорректного пользовательского ввода рассмотрен выше. Но точно также к некорректному пользовательскому
вводу можно отнести и неправильные данные во входных файлах, и неправильные данные, присланные по сети.
Отличительная особенность такого рода ошибок, что пользователь программы имеет полный контроль над вводимыми
данными.
Любая сколь-нибудь серьёзная программа должна обязательно обрабатывать ошибки пользовательского ввода.
С другой стороны, обработка такого рода ошибок, как правило самая простая. При обнаружении ошибки пользовательского
ввода можно завершить обработку запроса. При этом желательно вывести содержательное сообщение о виде и месте ошибки.

Ошибки взаимодействия возникают, когда программа взаимодействует с другими программами, а они ведут себя не так,
как ожидается. Например, программа неожиданно завершается, либо сетевое соединение разрывается.
Обработка таких ошибок осложняется тем, что в зависимости от текущего состояния взаимодействия может
потребоваться выполнить разные действия, чтобы вернуть программу в целостное состояние.

Ошибки, связанные с использованием общих ресурсов системы тоже достаточно часты. Например, требуемый файл не существует
в файловой системе, или файл не может быть открыт на запись. Такие ошибки тоже могут проистекать из пользовательского ввода,
например, если пользователь сам задаёт путь к файлу. Но бывают и случаи, когда общие ресурсы системы меняются по ходу работы,
например, изначально файл существовал, но потом был удалён. Это &mdash; ошибки класса "race condition".
Обработка такого рода ошибок в программе может быть достаточно проблематична, так как надо постараться вернуть
программу в целостное состояние, например, откатив назад пользовательский запрос.

Аппаратные ошибки возникают из-за сбоев аппаратуры, например, разрушился блок данных на диске, или закончилось место на диске.
К сожалению, такие ошибки часто игнорируются. Да, сбои оборудования достаточно редки, но если такая ошибка происходит
и при этом игнорируется в программе, это может приводить к тихой потере данных, то есть пользователь узнает (если узнает)
об ошибке намного позже, чем она произошла, и, возможно, часть данных будет безвозвратно утеряна.

Ошибки нехватки ресурсов &mdash; самый сложный для обработки тип ошибок. В особенности ошибки нехватки памяти.
Очень часто толком непонятно, как ее обрабатывать.

## Простая обработка ошибок

В качестве примера рассмотрим программу, которая считывает из файла, имя которого задаётся в командной строке, последовательность
целых чисел типа `int`, сортирует её по неубыванию, и отсортированный результат выводит на стандартный поток вывода.

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

struct Result
{
    _Bool   succ;
    size_t  size;
    int    *data;
};
static struct Result
read_array(const char *path)
{
    FILE *f = fopen(path, "r");
    int *data = NULL;
    size_t a = 0, u = 0;

    int x;
    while (fscanf(f, "%d", &x) != EOF) {
        if (u == a) {
            if (!(a *= 2)) a = 32;
            data = realloc(data, a * sizeof(data[0]));
        }
        data[u++] = x;
    }

    fclose(f);
    return (struct Result) { .succ = 1, .size = u, .data = data };
}

static int
sort_func(const void *p1, const void *p2)
{
    int v1 = *(const int *) p1;
    int v2 = *(const int *) p2;
    return v1 - v2;
}

int
main(int argc, char *argv[])
{
    struct Result res = read_array(argv[1]);
    qsort(res.data, res.size, sizeof(res.data[0]), sort_func);
    for (int i = 0; i < res.size; ++i) {
        printf("%d\n", res.data[i]);
    }
    free(res.data);
}
```

## О сортировке целых чисел

Сразу заметим, что в функции сортировки `sort_func` допущена грубая ошибка. Операция `v1 - v2` выполняется над знаковым
типом, поэтому в случае знакового переполнения, то есть, например, если из большого положительного числа вычитается
большое по абсолютному значению отрицательное, мы получим undefined behavior со всеми последствиями.

Идеоматический вариант написания правильной сортировки следующий.

```c
int
sort_func(const void *p1, const void *p2)
{
    int v1 = *(const int *) p1;
    int v2 = *(const int *) p2;
    if (v1 < v2) return -1;
    return v1 > v2;
}
```

Здесь два сравнения, но современные компиляторы распознают идеоматический код и хорошо его оптимизируют.

```asm
sort_func:
	movl	(%rsi), %eax
	cmpl	%eax, (%rdi)
	movl	$-1, %edx
	setg	%al
	movzbl	%al, %eax
	cmovl	%edx, %eax
	ret
```

А вот альтернативный вариант функции сравнения (обоснуйте, что он правильный):

```c
int
sort_func(const void *p1, const void *p2)
{
    int v1 = *(const int *) p1;
    int v2 = *(const int *) p2;
    int res;
    if (__builtin_sub_overflow(v1, v2, &res)) return v1;
    return res;
}
```

И он компилируется в чуть более эффективный код:

```asm
sort_func:
	movl	(%rdi), %ecx
	movl	%ecx, %eax
	subl	(%rsi), %eax
	cmovol	%ecx, %eax
	ret
```

## Обработка ошибок в main

Но вернёмся к нашей программе и сначала рассмотрим функцию `main`.
Никакой обработки ошибок в ней нет. Что нужно добавить:

* проверку, что в аргументах командной строки передан путь к файлу;
* проверку, что `read_array` завершился успешно;
* проверку, что вывод на `stdout` весь завершился успешно.

Обратите внимание, что функция `read_array` уже написана так, что возвращает флаг
успешности чтения в поле `succ`.

Обратите внимание, что в цикле вывода для переменной `i` используется тип `int`, в то время как
для хранения количества элементов &mdash; тип `size_t`. Тип переменных должен совпадать.
Например, переменная `i` должна иметь тип `size_t`, но возможен и вариант, что поле `res.size`
будет иметь тип `int`.

Модфицированная `main` может выглядеть так.

```c
int
main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments\n");
        exit(1);
    }

    program_name = argv[0];
    struct Result res = read_array(argv[1]);
    if (!res.succ) {
        exit(1);
    }

    qsort(res.data, res.size, sizeof(res.data[0]), sort_func);
    for (size_t i = 0; i < res.size; ++i) {
        printf("%d\n", res.data[i]);
    }
    fflush(stdout);
    if (ferror(stdout)) {
        fprintf(stderr, "%s: write error: %s\n", program_name, strerror(errno));
        exit(1);
    }

    free(res.data);
}
```

Чтобы проверить успешность записи выходного файла мы сначала вызываем `fflush` для окончательного
сохранения буфера вывода. Затем проверяется флаг ошибки записи дескриптора потока `stdout`.
Он будет установлен, если какая-то из операций записи (не обязательно последняя) вернет ошибку.

## Обработка ошибок в `read_array`

Обратим внимание на следующие моменты:

```
    while (fscanf(f, "%d", &x) != EOF) {
```

Это неправильное условие выполнения цикла. Если в файле встретится не-число,
то функция `fscanf()` вернет 0 и не считает ни одного символа из потока,
что приведет к зацикливанию программы. Правильно написать так:

```
    int r;
    while ((r = fscanf(f, "%d", &x)) != 1) {
```

результат выполнения `fscanf` мы сохраним в переменную `r` для последующего использования.

Во-вторых. Этот фрагмент перевыделяет память неаккуратно.

```
            data = realloc(data, a * sizeof(data[0]));
```

Если `realloc` по какой-то причине вернет `NULL`, возникнет утечка памяти. Ну и про возможное переполнение не стоит забывать.

Еще добавим проверку на открытие файла и улучшение диагностики при ошибке чтения. Получим следующую функцию.

```c
struct Result read_array(const char *path)
{
    FILE *f = fopen(path, "r");
    if (!f) {
        fprintf(stderr, "cannot open '%s': %s\n", path, strerror(errno));
        return (struct Result) {};
    }

    int *data = NULL;
    size_t a = 0, u = 0;

    int x, r;
    while ((r = fscanf(f, "%d", &x)) != EOF) {
        if (u == a) {
            if (!a) {
                a = 32;
            } else if (!(a *= 2)) {
                // a overflown
                fprintf(stderr, "data too big\n");
                fclose(f);
                free(data);
                return (struct Result) {};
            }
            size_t z;
            if (__builtin_mul_overflow(a, sizeof(data[0]), &z)) {
                fprintf(stderr, "data too big\n");
                fclose(f);
                free(data);
                return (struct Result) {};
            }
            int *tmp_data = realloc(data, z);
            if (!tmp_data) {
                fprintf(stderr, "out of memory\n");
                fclose(f);
                free(data);
                return (struct Result) {};
            }
            data = tmp_data;
        }
        data[u++] = x;
    }
    if (!r) {
        fprintf(stderr, "format error '%s'\n", path);
        fclose(f);
        free(data);
        return (struct Result) {};
    }
    if (ferror(f)) {
        fprintf(stderr, "I/O '%s': %s\n", path, strerror(errno));
        fclose(f);
        free(data);
        return (struct Result) {};
    }

    fclose(f);
    return (struct Result) { .succ = 1, .size = u, .data = data };
}
```

Но у этой функции весь код загроможден корректным освобождением
ресурсов при ошибке. Для чистки кода воспользуемся `goto`. Получим окончательный вариант.

```c
struct Result
read_array(const char *path)
{
    FILE *f = NULL;
    int *data = NULL;

    if (!(f = fopen(path, "r"))) {
        fprintf(stderr, "cannot open '%s': %s\n", path, strerror(errno));
        goto fail;
    }

    size_t a = 0, u = 0, z;

    int x, r;
    while ((r = fscanf(f, "%d", &x)) != EOF) {
        if (u == a) {
            if (!a) {
                a = 32;
            } else if (!(a *= 2) || __builtin_mul_overflow(a, sizeof(data[0]), &z)) {
                fprintf(stderr, "data too big\n");
                goto fail;
            }
            int *tmp_data = realloc(data, z);
            if (!tmp_data) {
                fprintf(stderr, "out of memory\n");
                goto fail;
            }
            data = tmp_data;
        }
        data[u++] = x;
    }
    if (!r) {
        fprintf(stderr, "format error '%s'\n", path);
        goto fail;
    }
    if (ferror(f)) {
        fprintf(stderr, "I/O '%s': %s\n", path, strerror(errno));
        goto fail;
    }

    fclose(f);
    return (struct Result) { .succ = 1, .size = u, .data = data };

fail:
    free(data);
    if (f) fclose(f);
    return (struct Result) {};
}
```

# Преобразование между строками и числами

Преобразование из целого числа (любого типа) в строку и из строки в целое число
&mdash; одна из наиболее часто востребованных вещей в программировании. Но преобразование
в любую сторону должно быть выполнено корректно и безопасно.

## Преобразование из числа в строку

В стандарте Си нет функции, непосредственно выполняющей преобразование из числа в строку,
как функция `itoa`, существующая в Windows. Поэтому будем использовать варианты функции `printf`.

Первый вариант:

```c
    char buf[64];
    sprintf(buf, "%d", value);
```

Это нормальный вариант, так как вряд ли длина строкового представления может быть больше 63 байта.
Но функция `sprintf` в принципе небезопасная, так как невозможно проверить,
что при преобразовании в строку не произошло переполнение буфера.
Для контроля за переполнением буфера лучше использовать `snprintf`.

```c
    char buf[64];
    if (snprintf(buf, sizeof(buf), "%d", value) >= sizeof(buf)) {
        // преобразование не поместилось в buf
        abort();
    }
```

Но можно воспользоваться и функцией `asprintf`:

```c
    char *buf = NULL;
    asprintf(&buf, "%d", value);
    ...
    free(buf);
```

Строка размещается в области динамической памяти. Это медленно по сравнению с размещением в локальном буфере,
но может быть единственным вариантом, если указатель надо вернуть из функции. Ну и кроме того,
выделение динамической памяти может оказаться неудачным.

## Преобразование из строки в число

При преобразовании из строки в число могут возникать несколько ошибочных ситуаций.
* на входе пустая строка `""`
* на входе слишком большое число `"99999999999999999999999999999999999"`
* "мусорные" символы после числа `"1zzz"`
* если выполняется преобразование в тип `int`, типы `long` и `int` могут иметь разную битность,
и число, представимое в типе `long` может быть непредставимым в типе `int`.

Получаем следующий фрагмент:

```c
    char *eptr = NULL;
    errno = 0;
    long lval = strtol(str, &eptr, 10);
    if (errno || *eptr || eptr == str || (int) lval != lval) {
        // ошибка преобразования
    }
```

В этом фрагменте проверки в `if` имеют следующий смысл:
* `eptr == str` проверяет, что на входе не пустая строка
* `errno` проверяет, что не произошло переполнения при преобразовании строки в `long`
* `*eptr` проверяет, что после строки нет "мусора"
* `(int) lval != lval` проверяет, что считано число, представимое в `int`
