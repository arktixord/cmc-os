# Работа с процессами в POSIX-системах, часть 2

Системный вызов `fork` и его разновидности (`vfork`, `clone`) создаёт новый процесс,
являющийся почти во всем копией текущего процесса. Новый процесс исполняет тот же код,
что и текущий процесс. Чтобы запустить на выполнение другой исполняемый файл
необходим отдельный системный вызов или библиотечная функция семейства `exec*`.

Семейство `exec*` работает в рамках уже созданного процесса, полностью заменяя у него
виртуальную память. После этого "в оболочке" процесса начинает работать другая программа.
Иногда это действие называется "замещением тела процесса". Замещение тела процесса
включает в себя следующие действия:
* копирование аргументов командной строки и окружения процесса из виртуального адресного
пространства процесса во временный буфер в пространстве ядра ОС;
* полное уничтожение виртуального адресного пространства процесса;
* создание основного стека процесса и копирование в него аргументов командной строки и
переменных окружения;
* загрузка в виртуальное адресное пространство новой программы и необходимых библиотек
и передача управления на точку входа новой программы.

## Системный вызов `execve`

Основной системный вызов для замещения тела процесса - `execve`, определенный следующим образом:

```c
#include <unistd.h>

int execve(const char *pathname, char *const argv[], char *const envp[]);
```

Аргумент `pathname` &mdash; это абсолютный или относительный путь к исполняемому файлу для запуска.
`argv` &mdash; массив аргументов командной строки для запускаемой программы, `envp` &mdash; окружение
запускаемой программы.

В случае успешного выполнения системного вызова виртуальное адресное пространство процесса полностью
заменяется. Поэтому можно считать, что на системном вызове `execve` исполнение программы завершается
и следующие за вызовом `execve` строки кода вообще не выполняются. Но если `execve` не смог загрузить
указанный исполняемый файл, то возвращается значение `-1`, а переменная `errno` будет содержать
код ошибки. По сути можно предполагать, что сразу после системного вызова `execve` должна находиться
обработка ошибки, при этом проверять на возвращаемое значение не обязательно.

У файла `pathname` должны быть права на исполнение для эффективного идентификатора
пользователя процесса, то есть должно выполняться `access(pathname, X_OK) >= 0`. Даже пользователь
root не может запустить на исполнение файл, у которого не установлен бит `x` прав доступа.

Аргументы командной строки передаются в параметре `argv`. Это должен быть адрес начала массива указателей
на строки, которые будут переданы в запускаемую программу. Последним обрабатываемым элементом массива
указателей является указатель NULL. Массив указателей и строки могут быть разбросаны по виртуальному адресному пространству
произвольным образом, все равно в случае успеха они будут скопированы в стек запущенной программы.
Но в случае неуспешного завершения `execve` корректное освобождение памяти остается за программой.

Строки, передаваемые в массиве `argv`, будут без изменений переданы в аргумент `argv` функции `main`. Обратите
внимание, что в системный вызов `execve` не передается значение `argc` (число параметров командной строки),
знакомое нам по аргументам функции `main`. Значение `argc` вычисляется внутри системного вызова `execve`
по количеству ненулевых указателей в `argv`. Поэтому в массиве `argv` все указатели, кроме последнего,
гарантированно ненулевые, а последний указатель &mdash; гарантированно `NULL`.

Окружение в запускаемую программу передаётся с помощью параметра `envp`. Это должен быть адрес начала
массива указателей на строки, которые будут переданы в запускаемую программу как окружение.
Последним обрабатываемым элементом массива
указателей является указатель NULL. Массив указателей и строки могут быть разбросаны по виртуальному адресному пространству
произвольным образом, все равно в случае успеха они будут скопированы в стек запущенной программы.
Но в случае неуспешного завершения `execve` корректное освобождение памяти остается за программой.

Окружение процесса &mdash; это набор поименованных строковых значений. Некоторые переменные окружения имеют
специальный смысл для функций стандартной библиотеки или для утилит командной строки.
При запуске программы на выполнение с помощью `execve` есть несколько вариантов.

1. Передать в запускаемую программу копию текущих переменных окружения. Для этого нужно использовать
значение глобальной переменной `environ`. Однако, по какой-то причине, эта переменная не объявляется
в заголовочных файлах стандартной библиотеки, поэтому нужно объявить эту переменную явно в начале программы.

```c
extern char **environ;
```

Затем в качестве аргумента `envp` передается значение `environ`.

2. Передать в запускаемую программу модифицированное текущее окружение. Для этого сначала с помощью
функций стандартной библиотеки `setenv` или `putenv` модифицируется окружение, затем в
качестве параметра `envp` передается значение переменной `environ`, как показано выше.

3. Передать пустое окружение. В случае пустого окружения некоторые функции стандартной библиотеки,
которые, возможно, используются запускаемой программой, могут работать некорректно. Поэтому передавать
пустое окружение, пожалуй, не стоит. Но если хочется это сделать, передавайте `NULL` в качестве параметра
`envp`.

4. Передать в запускаемую программу полностью сформированное новое окружения. Для этого нужно
создать массив указателей на строки и передать его в `envp`.

## Идиома fork/exec

Одной из типичных операций, выполняемых под управлением операционных систем, является запуск исполняемых
файлов на выполнение в отдельном процессе. В некоторых операционных системах эта операция выполняется
одним вызовом, например, `CreateProcess`. Стандарт POSIX документирует функции `posix_spawn` и `posix_spawnp`,
которые также запускают исполняемый файл в новом процессе. Существуют библиотечные функции `system` и `popen`.
Однако классическая идиома для запуска исполняемого файла в новом процессе &mdash; это сначала создание нового
процесса с помощью `fork`, с последующей заменой тела процесса с помощью подходящей функции семейства `exec*`.

Последовательность системных вызовов для запуска исполняемого файла начинается с системного вызова `fork`,
создающего копию текущего процесса, далее в процессе-сыне выполняется настройка параметров процесса,
например, перенаправление стандартных потоков, смена текущего каталога и т. п. Затем выполняется одна
из функций семейства `exec*`, и управление передаётся на нужный исполняемый файл.

Необходимые действия выполняются следующим фрагментом:

```c
    pid_t pid = fork();
    if (pid < 0) {
        // обработать ошибку нехватки ресурсов для создания нового процесса
    } else if (!pid) {
        // процесс-сын
        // настроить параметры процесса-сына: стандартные потоки и пр.
        execve(path, argv, environ); // загрузить исполняемый файл
        // если выполняется код здесь, значит execve завершился с ошибкой
        // возможно, сообщить об ошибке запуска исполняемого файла
        _exit(1); // предпочтительно использовать `_exit`
    } else {
        // процесс-отец
        // возможны разные ситуации синхронного/асинхронного исполнения
    }
```

В дальнейшем использование идиомы `fork/exec` будет детализировано для типовых случаев.

## Какие атрибуты процесса не сохраняются в результате `exec*`

Многие атрибуты процесса не изменяются в результате запуска исполняемой программы с помощью `exec*`.
Например, сохраняется идентификатор процесса, идентификатор процесса-родителя, идентификатор группы процессов
и сессии. Не изменяются параметры планирования процесса (значение nice), текущий каталог, корневой каталог, umask
и т. п. Сохраняется множество блокируемых (blocked), игнорируемых (ignored) сигналов и множество сигналов,
ожидающих доставки (pending).

Но, поскольку виртуальное адресное пространство процесса в результате `exec` полностью заменяется, атрибуты
процесса, зависящие от виртуального адресного пространства, сбрасываются. Далее перечислены атрибуты процесса,
которые не сохраняются в результате успешного вызова `exec`.

* Открытые файловые дескрипторы обычно сохраняются в результате `exec`. Однако если у файлового дескриптора
установлен флаг `O_CLOEXEC` (или его варианты, например, `EFD_CLOEXEC`), файловый дескриптор будет закрыт
при успешном выполнении `exec*`. Флаг `O_CLOEXEC` &mdash; удобный способ избегать утечек файловых
дескрипторов.

* Эффективный идентификатор пользователя (euid) обычно сохраняется, но если у исполняемого файла установлен suid бит,
то эффективный идентификатор пользователя устанавливается в идентификатор владельца файла.

* Аналогично, эффективный идентификатор группы (egid) обычно сохраняется, но если у исполняемого файла установлен
sgid бит, то эффективный идентификатор группы устанавливается в идентификатор группы файла.

* Сигналы, для которых установлены пользовательские обработчики, сбрасываются на обработку по умолчанию.

* Очереди сообщений POSIX закрываются.

* Именованные семафоры POSIX закрываются.

* Открытые с помощью `opendir` каталоги закрываются.

* Таймеры POSIX закрываются.

* Файлы, отображенные в память, разделяемые сегменты памяти POSIX, разделяемая память SysV, страницы, заблокированные
в ОЗУ (mlock), обработчики завершения программы (atexit) уничтожаются.

* Все нити, кроме текущей, уничтожаются.

* Незавершенные асинхронные операции (`aio_read` и пр.) отменяются.

## Скрипты

Стандартным форматом для исполняемых файлов в современных POSIX-ориентированных операционных системах
является формат ELF (Executable and Linkage Format). Этот формат определяет размещение в исполняемом
файле различных частей программы, которые отображаются в виртуальное адресное пространство процесса.
Вообще говоря, даже для динамически скомпонованных исполняемых файлов формата ELF для их запуска
на выполнение требуется вспомогательная программа &mdash; динамический загрузчик, путь к которому
прописывается в специальном месте исполняемого файла, но это будет рассмотрено отдельно.

В POSIX-ориентированных операционных системах реализован механизм для запуска произвольной
программы (программы-интерпретатора) при выполнении системного вызова `execve`. Как
и в случае "обычного" бинарного исполняемого файла и такие файлы должны иметь право исполнения (`x`)
для текущего пользователя.
Для этого начало запускаемого файла должно иметь следующий вид:

```
#! INTERPRETER [OPTION]\n
```

То есть первые два байта файла должны быть `'#'` и `'!'`, затем может следовать один или несколько пробелов,
за которыми должен следовать абсолютный путь к программе-интерпретатору `INTERPRETER`.
Далее может задаваться опция (аргумент командной строки) для программы-интерпретатора. Опция может отсутствовать.
Спецификация для запуска интерпретатора должна заканчиваться символом `'\n'`. У спецификации есть несколько особенностей:

* поддерживается только один дополнительный аргумент (опция) командной строки для программы-интерпретатора. Если задать
несколько аргументов, например,
```
#! /bin/interpreter -a -b
```
то все, что следует после абсолютного пути к интерпретатору, рассматривается как один аргумент, то
есть интерпретатору `/bin/interpreter` будет передана опция `-a -b` в одном аргументе командной строки.

* если запускаемый файл является текстовым файлом в DOS-формате, то есть каждая строка текста заканчивается в нем
парой байт `'\r'` и `'\n'`, то символ `'\r'` будет рассматриваться не как символ конца строки, и не как пробельный
символ, а как часть дополнительного аргумента командной строки для программы-интерпретатора.

Аргументы командной строки, заданные при запуске скрипта, будут добавлены после пути к интерпретатору,
дополнительного аргумента и имени скрипта. Например, если запускается программа по пути `./script`,
при запуске передаются аргументы командной строки `script`, `1`, `2`,
а файл `script` содержит в начале
```
#! /bin/interpreter -a -b
```

тогда в программу `/bin/interpreter` будут переданы следующие аргументы командной строки:
```
/bin/interpreter
-a -b
./script
1
2
```

Обратите внимание, что в качестве имени скрипта передается именно путь к запускаемой программе,
а не передаваемый в системный вызов `exec*` нулевой аргумент командной строки `argv[0]`.

Программа `/bin/interpreter` сама может быть программой-скриптом, для запуска которой
требуется свой интерпретатор. Разные версии POSIX-ориентированных операционных систем
по-разному ограничивают рекурсию. Например, в Linux максимальная глубина рекурсии
при раскрытии программы-интерпретатора равна 5.

Последовательность символов `'#'`, `'!'` выбрана такой, потому что во многих скриптовых
языках (shell, perl, python, ruby, awk ...) символ `'#'` является символом начала комментария,
который размещается до конца текущей строки. Поэтому последовательность, начинающаяся с `'#'`
с точки зрения этих языков является комментарием.

Если запускаемый с помощью `exec*` файл не распознан ни как исполняемый файл в формате ELF,
ни как исполняемый файл в других поддерживаемых ядром ОС формате, ни как файл скрипта,
начинающийся с `#!`, то для исполнения такого файла будет использоваться стандартный
интерпретатор командной строки `/bin/sh`.

## Другие варианты `exec*`

Помимо системного вызова `execve` стандартная библиотека предлагает еще
несколько библиотечных функций-надстроек над системным вызовом `execve`,
которые в некоторых случаях могут оказаться удобнее в использовании.

Эти библиотечные функции перечислены ниже.

```c
int execl(const char *pathname, const char *arg, ... /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
```

Имена функций построены по одному шаблону: после имени `exec` идёт суффикс, содержащий буквы, уточняющие типы и количество передаваемых
параметров. Они расшифровываются следующим образом:

* Если в суффиксе имени присутствует буква `e` (например, `execve`), то данная функция принимает указатель `envp` на массив
переменных окружения, который должен быть передан запускающей программе. Если в суффиксе буква `e` отсутствует (например, `execlp`),
то параметр `envp` у функции отсутствует, и в запускаемую программу передается копия текущего окружения процесса,
полученная из глобальной переменной `environ`.

* Если в суффиксе имени присутствует буква `p` (например, `execlp`), то в качестве первого аргумента данная функция может принимать
имя программы `file`. Имя программы &mdash; это строка, не содержащая символ `'/'`. Если передано имя программы, то выполняется
поиск программы с таким именем в списке каталогов, перечисленных в переменной окружения `PATH`. Если в качестве первого аргумента
передана строка, содержащая символ `'/'`, то такая строка рассматривается как абсолютный или относительный путь к файлу,
и переменная окружения `PATH` использоваться не будет. Если в суффиксе имени функции буква `p` отсутствует (например, `execve`),
то в качестве первого аргумента принимается абсолютный или относительный путь к запускаемому файлу.

* Если в суффиксе имени присутствует буква `l` (например, `execl`), то аргументы командной строки для запускаемой
программы передаются непосредственно в аргументах этой функции. Концом передаваемых аргументов для запускаемой программы
является аргумент `NULL`, переданный в функцию. Если в суффиксе имени присутствует буква `v` (например, `execv`),
то аргументы командной строки передаются в массиве указателей на строки, адрес которого передается в параметре `argv`.

Например, 
```c
    execlp("ls", "ls", "-l", NULL);
```
в качестве имени программы передана строка `ls`. Будет выполнен поиск программы `ls` в каталогах, перечисленных
в переменной окружения `PATH`. Скорее всего программа будет найдена по пути `/bin/ls`, и в итоге в системный вызов
`execve` в качестве пути к исполняемому файлу будет передан путь `/bin/ls`. Аргументы командной строки
будут собраны в массив `argv` из аргументов функции `execlp`, и в итоге в программу `/bin/ls`
будет передан массив строк `{ "ls", "-l", NULL }`. Обратите внимание, что `argv[0]` был сохранен
в том виде, в котором он был передан в функцию `execlp` (второй параметр вызова функции `execlp`).

В случае
```c
    execl("ls", "ls", "-l", NULL);
```
переменная `PATH` использоваться не будет, путь `ls` будет рассматриваться как относительный путь, и если
в текущем каталоге процесса нет исполняемого файла с именем `ls`, этот вызов завершится с ошибкой.

Обратите внимание, что следующий вызов содержит грубую ошибку:
```c
    execlp("ls", "ls", "-l", 0);
```

Хотя почти всегда в программе на Си вместо `NULL` можно использовать 0, здесь так делать нельзя.
Дело в том, что функция `execlp` &mdash; это функция с переменным числом аргументов (variadic function).
В них литеральное значение 0 рассматривается как константа типа `int`, а неявное преобразование
0 к нулевому указателю не выполняется. В случае, если `sizeof(void*) != sizeof(int)`,
например, на 64-битных платформах, вместо нулевого указателя в стек может быть занесено
некоторое значение, которое только в младших 32-битах будет нулевым, а старшие 32 бита будут
ненулевыми. Получится некорректный указатель, что приведет к undefined behavior
и, возможно, к аварийному завершению программы.

## Использование стандартного командного интерпретатора `/bin/sh` для разбора командной строки.

Функции семейства `exec*` требуют массив строк для передачи в аргументы командной строки запускаемой
программы. Если же команда для запуска передана как одна строка, например, `"ls -l"`,
строку потребуется разобрать на отдельные аргументы командной строки. При этом, возможно,
потребуется учитывать разные формы кавычек и другие особенности командной строки shell.
Одним из вариантов реализации разбора командной строки является использование стандартного
интерпретатора командной строки `/bin/sh`. Если дана строка `str`, содержащая команду для запуска,
то исполнить ее можно с помощью следующего вызова:

```c
    execl("/bin/sh", "sh", "-c", str, NULL);
```

В качестве пути к интерпретатору командной строки указан путь `/bin/sh`, а опция `-c`
интерпретатора командной строки обозначает, что будет проанализирована переданная строка,
она будет исполнена, после чего интерпретатор командной строки сам завершит работу.

Этот способ разбора командной строки очень прост в реализации, однако не очень эффективен,
так как потребуется время на инициализацию программы `/bin/sh`. Кроме того,
командная строка будет запущена в новом процессе, и `/bin/sh` будет дожидаться его завершения,
что может затруднить управление процессами.

Стандартная библиотека Си предлагает функцию `system`, которая запускает команду, переданную как строку,
и дожидается окончания ее выполнения. Упрощенная реализация функции `system` может выглядеть следующим образом:

```c
int system(const char *str)
{
    pid_t pid = fork();
    if (pid < 0) {
        return -1;      // возвращается признак ошибки
    }
    if (!pid) {
        // процесс-сын
        execl("/bin/sh", "sh", "-c", str, NULL);
        _exit(127);
    }
    // процесс-отец, ждем запущенного сына
    int status = 0;
    waitpid(pid, &status);
    if (WIFSIGNALED(status)) {
        return 128 + WTERMSIG(status);
    } else {
        return WEXITSTATUS(status);
    }
}
```

## Перенаправление стандартных потоков

Если у запускаемой программы необходимо выполнить перенаправление стандартных потоков,
используются системные вызовы семейства dup: `dup`, `dup2` или `dup3`. Для перенаправления стандартного
потока ввода нужно подменить файловый дескриптор 0, для перенаправления стандартного потока вывода &mdash;
файловый дескриптор 1, и для перенаправления стандартного потока ошибок &mdash; файловый дескриптор 2.

Рассмотрим следующую команду:
```
./program < file1 > file2 2>> file3
```
она означает, что у запускаемой программы `./program` стандартный ввод должен быть перенаправлен
из файла `file1`, стандартный вывод должен быть перенаправлен в файл `file2`, а стандартный
поток ошибок должен быть перенаправлен в файл `file3` в режиме добавления.

Для этого потребуется следующий фрагмент программы:
```c
    pid_t pid = fork();
    if (pid < 0) {
        // обработать ошибку создания нового процесса
    } else if (!pid) {
        int fd = open("file1", O_RDONLY);
        if (fd < 0) {
            // ошибка открытия файла
            _exit(1);
        }
        dup2(fd, 0); // скопировать файловый дескриптор fd в файловый дескриптор 0
        close(fd);   // fd больше не нужен и должен быть закрыт

        fd = open("file2", O_WRONLY | O_CREAT | O_TRUNC, 0666); // открыть файл в режиме перезаписи
        if (fd < 0) {
            // ошибка открытия файла
            _exit(1);
        }
        dup2(fd, 1); // скопировать файловый дескриптор fd в файловый дескриптор 1
        close(fd);   // fd больше не нужен и должен быть закрыт

        fd = open("file3", O_WRONLY | O_CREAT | O_APPEND, 0600); // открыть файл в режиме добавления
        if (fd < 0) {
            // ошибка открытия файла
            _exit(1);
        }
        dup2(fd, 2); // скопировать файловый дескриптор fd в файловый дескриптор 2
        close(fd);   // fd больше не нужен и должен быть закрыт

        execlp("./program", "./program", NULL);
        _exit(1);
    }
```

Обратите внимание, что файлы, с которыми нужно связать стандартные потоки, следует открывать
в процессе-сыне после `fork`, так как процессу-отцу эти файлы не нужны, и он их не использует.

Кроме того, чтобы файловые дескрипторы открытых файлов "не утекали" в запускаемую программу,
они должны быть обязательно закрыты. Чуть упростить этот фрагмент можно, если использовать
флаг `O_CLOEXEC` при открытии файлов:
```c
    pid_t pid = fork();
    if (pid < 0) {
        // обработать ошибку создания нового процесса
    } else if (!pid) {
        int fd = open("file1", O_RDONLY | O_CLOEXEC);    // файловый дескриптор будет закрыт автоматически при execlp
        if (fd < 0) {
            // ошибка открытия файла
            _exit(1);
        }
        dup2(fd, 0); // скопировать файловый дескриптор fd в файловый дескриптор 0

        fd = open("file2", O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0666); // открыть файл в режиме перезаписи
        if (fd < 0) {
            // ошибка открытия файла
            _exit(1);
        }
        dup2(fd, 1); // скопировать файловый дескриптор fd в файловый дескриптор 1

        fd = open("file3", O_WRONLY | O_CREAT | O_APPEND | O_CLOEXEC, 0600); // открыть файл в режиме добавления
        if (fd < 0) {
            // ошибка открытия файла
            _exit(1);
        }
        dup2(fd, 2); // скопировать файловый дескриптор fd в файловый дескриптор 2

        execlp("./program", "./program", NULL);
        _exit(1);
    }
```

Системные вызовы семейства `dup` не копируют флаг `O_CLOEXEC`, поэтому у файловых дескрипторов
стандартных потоков он будет сброшен, и эти файловые дескрипторы будут переданы в запущенную
программу, в то время, как файловые дескрипторы открытых для перенаправления файлов
будут закрыты автоматически.

## Системный вызов `fexecve`

Многие функции работы с файлами в файловой системе реализованы в двух вариантах:
когда системный вызов принимает путь к файлу, и когда системный вызов принимает открытый
файловый дескриптор, например, `stat` и `fstat`, `chmod` и `fchmod`. Кроме того,
современные ядра Linux предоставляют расширенные системные вызовы семейства `*at`,
например, `fstatat`, `openat` и т. п., но эти системные вызовы мы рассматривать не будем.

Для системного вызова `execve` парой является функция `fexecve`, определенная следующим образом:

```c
#include <unistd.h>

int fexecve(int fd, char *const argv[], char *const envp[]);
```

Файловый дескриптор `fd` должен быть открыт в режиме "только чтение" (`O_RDONLY`),
а файл, с которым он связан, должен быть регулярным и доступным на выполнение (бит `x`)
для текущего пользователя.

Рекомендуется открывать файловый дескриптор `fd` в режиме автоматического закрытия при exec
(флаг `O_CLOEXEC`), чтобы файловый дескриптор исполняемого файла не "утекал"
в запускаемую программу. Однако, в этом случае становится невозможным запустить
на выполнение исполняемые скрипты, которые требуют для своего исполнения программы-интерпретатора.
В этом случае вызов `fexecve` завершится с ошибкой `ENOENT`.
