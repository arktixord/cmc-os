# Системные вызовы

## Системные вызовы

Под процессом мы будем понимать программу в состоянии выполнения (это не определение понятия).
Выполняющаяся программа (т.е. процесс) потребляет ресурсы компьютера:
процессорное время, оперативную память, дисковое пространство и пр. 

За распределение ресурсов компьютера между работающими процессами отвечает
ядро (kernel) операционной системы. Ядро &mdash; это ключевой компонент
операционной системы, оно начинает работу при загрузке компьютера
и работает до его выключения. Ядро работает в привелегированном режиме
работы центрального процессора, то есть имеет доступ ко всем возможностям ЦП.

Ядро изолирует процессы друг от друга и от аппаратуры компьютера.
Ядро предоставляет процессам виртуальное процессорное время, виртуальную
память, то есть некоторый "образ" оперативной памяти.
Процесс работает в пользовательском режиме (user mode) и не может выполнять “чувствительные” инструкции
(настройка MMU, работа с внешними устройствами...).

Процесс в пользовательском режиме не может выполнить операции
ввода-вывода, выделения памяти и даже завершения работы.
Для выполнения подобных операций процесс запрашивает ядро
операционной системы с помощью механизма, называющегося
системным вызовом. Ядро ОС проверяет полномочия
процесса, запросившего операцию, и выполняет ее.
После завершения операции процессор переключается
обратно в пользовательский режим и управление
возвращается в процесс.

Системный вызов похож на вызов подпрограммы тем, что управление
возвращается на инструкцию программы, непосредственно
следующую за инструкцией системного вызова. Но системный вызов (выполнение
собственно инструкции входа в системный вызов и возвтрата из него)
может быть в тысячи раз медленнее обычного вызова подпрограммы.

Собственно системный вызов &mdash; это специальная инструкция процессора,
которая инициирует передачу управления в ядро операционной системы.
Разные операционные системы даже на одном процессоре могут использовать
разные инструкции системного вызова.

## Низкоуровневый интерфейс системных вызовов

Системные вызовы идентифицируются своим номером. Современные версии
ядра linux реализуют около 400 различных системных вызовов. Набор констант
для номеров системных вызовов для Linux x86 находится в файле `<asm/unistd_32.h>`,
а для Linux x64 в файле `<asm/unistd_64.h>`.

На Linux/x86 инструкция системного вызова &mdash; это `int $0x80`.
Перед выполнением инструкции системного вызова в регистр `eax` нужно
поместить номер системного вызова, а в регистры `ebx`, `ecx`, `edx`, `esi`, `edi`, `ebp`
в этом порядке.

Результат выполнения системного вызова возвращается в регистре `eax`,
значение остальных регистров процессора не изменяется.

## Высокоуровневый интерфейс системных вызовов

Чтобы программа на Си была переносима между разными версиями
операционных систем на разных архитектурах необходима возможность
выполнения системных вызовов из программ на Си.

Поэтому обычно системные вызовы документируют в терминах языка Си.
Обычно указываются заголовочные файлы, которые необходимо
подключить, типы аргументов и возвращаемых значений.

Стандартная библиотека Си (libc) содержит вспомогательные функции ("мосты"),
которым передаются параметры в соответствии с соглашениями о вызовах
языка Си. Задача таких функций &mdash; подготовить параметры
в соответствии с соглашениями о передаче параметров в системные
вызовы, выполнить инструкцию системного вызова, а затем вернуть результат.

Такие библиотечные функции мы тоже будем называть системными вызовами.
Например, в ядре Linux/x86 системный вызов с номером 5 открывает
файл на чтение или запись. Ему соответствует функция стандартной
библиотеки `open`, поэтому мы будем готоворить, что системный
вызов `open` выполняет операцию открытия файла.

Так, системный вызов `_exit`, который на Linux/x86 имеет номер 1,
завершает работу процесса. Это &mdash; главный способ завершения
работы процесса. Однако, стандартная библиотека Си содержит и
функцию `exit`, которая является более высокоуровневой оберткой
над системным вызовом `_exit`.

Набор заголовочных файлов для использования POSIX API работы с файлами:
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
```

## Файловые дескрипторы

Все открытые файлы представлены в ядре файловыми дескрипторами. Файловый дескриптор – это неотрицательное целое число. Когда процесс открывает существующий файл или создает новый, ядро возвращает ему файловый дескриптор. Чтобы выполнить записьв файл или чтение из него, нужно
передать системному вызову `read` или `write` его файловый дескриптор, полученный
в результате вызова системного вызова `open` или `creat`.
В соответствии с принятыми соглашениями командные оболочки UNIX ассоциируют файловый дескриптор 0 со стандартным устройством ввода процесса, 1 – со стандартным устройством вывода и 2 – со стандартным устройством
вывода сообщений об ошибках. Это соглашение используется командными
оболочками и большинством приложений, но не является особенностью ядра UNIX. Тем не менее многие приложения не смогли бы работать, если это соглашение было бы нарушено.

### Системный вызов `open`

```c
#include <fcntl.h>
int open(const char *pathname, int oflag, ... /* mode_t mode*/);
```

Возвращает дескриптор файла в случае успеха, –1 в случае ошибки.
Третий аргумент обозначен многоточием (...), таким способом стандарт ISO
C указывает, что количество остальных аргументов и их типы могут варьироваться. В этой функции третий аргумент используется только при создании нового файла. Этот аргумент приведен в прототипе функции как комментарий. Аргумент pathname представляет имя файла, который будет открыт или создан. Эта функция может принимать большое количество параметров, которые определяются аргументом oflag. Значение этого аргумента формируется
объединением по ИЛИ (OR) одной или более констант, определяемых в заголовочном файле fcntl.h и перечисленных ниже:

`O_RDONLY`  Файл открывается только на чтение.

`O_WRONLY`  Файл открывается только на запись.

`O_RDWR` Файл открывается как для чтения, так и для записи.

Должна быть указана одна и только одна из этих трех констант. 
Cписок констант, присутствие которых в аргументе oflag необязательно:

`O_APPEND` Запись производится в конец файла.

`O_CREAT` Если файл не существует, он будет создан. Этот флаг требует наличия третьего аргумента функции open(mode), который определяет значения битов прав доступа к создаваемому файлу.

`O_EXCL` Приводит к появлению ошибки, если файл уже существует и задан флаг `O_CREAT`. При такой комбинации флагов атомарно выполняется проверка существования файла и его создание, если файл не существует.

`O_TRUNC` Если файл существует и успешно открывается на запись либо на чтение и запись, то его размер усекается до нуля.

`O_NOCTTY` Если аргумент pathname ссылается на файл терминального устройства, то это устройство не назначается управляющим терминалом вызывающего процесса. 

`O_NONBLOCK` Если аргумент pathname ссылается на именованный канал (FIFO), специальный блочный файл или специальный символьный файл, этот флаг задает неблокирующий режим открытия файла и последующих операций
ввода вывода.

### Системный вызов `close`

```c
#include <unistd.h>
int close(int filedes);
```

Возвращает 0 в случае успеха, -1 в случае ошибки. Закрытие файла также приводит к снятию любых блокировок, которые мог ли быть наложены процессом. При завершении процесса все открытые им файлы автоматически закрываются ядром. 
Нужно понимать, что даже в случае, когда `close` завершается с ошибкой, сам
файловый дескриптор закрывается. Поэтому если `close` завершился с ошибкой,
что-либо сделать уже невозможно, перезапустить неудавшуюся операцию
не получится, так как файловый дескриптор уже освобожден.

### Системный вызов `lseek`

С регулярным открытым файлом связано такое понятие, как текущая позиция файла. Как правило, это неотрицательное целое число, которым выражается количеством байт от начала файла. Обычно операции чтения и записи начинают выполняться с текущей позиции файла и увеличивают ее значение на количество байт, которое было прочитано или записано. По умолчанию при открытии файла текущая позиция инициализируется числом 0, если не был установлен флаг O_APPEND. Явное изменение текущей позиции файла выполняется с помощью функции lseek.

```c
#include <unistd.h>
off_t lseek(int filedes, off_t offset, int whence);
```

Возвращает новую текущую позицию файла в случае успеха, –1 в случае ошибки

Интерпретация аргумента `offset` зависит от значения аргумента `whence`.

Если аргумент `whence` имеет значение `SEEK_SET`, то `offset` интерпретируется как смещение от начала файла.

Если аргумент `whence` имеет значение `SEEK_CUR`, то `offset` интерпретируется как смещение от текущей позиции файла. В этом случае offset может принимать как положительные, так и отрицательные значения.

Если аргумент `whence` имеет значение `SEEK_END`, то `offset` интерпретируется как смещение от конца файла. В этом случае offset может принимать как положительные, так и отрицательные значения.

Поскольку в случае успеха функция lseek возвращает новую текущую позицию файла, можно задать в аргументе offset значение 0, чтобы узнать текущую позицию:

```c
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
```

Можно воспользоваться этим приемом, чтобы определить, имеется ли возможность свободного перемещения текущей позиции файла. Если файловый дескриптор относится к именованному или неименованному каналу или к сокету, функция lseek вернет значение –1 и запишет в переменную errno код ошибки ESPIPE.

Текущая позиция файла может превышать его текущий размер. В этом случае следующая операция записи увеличит размер файла. Это вполне допустимо и может рассматриваться как создание «пустоты» в файле. Байты, которые фактически не были записаны, считываются как нули. «Пустота» в файле не обязательно должна занимать место на диске. В некоторых файловых системах в случае переноса текущей позиции за пределы файла на диске могут быть выделены новые блоки для данных, но это совершенно необязательно. 

Операция позиционирования или получения текущей позиции доступна не всегда.
Для сокетов, пайпов, терминалов, символьных устройств и некоторых других
эта операция недоступна. Системный вызов `lseek` вернет соответствующий код
ошибки.

### Системный вызов `read`

```c
#include <unistd.h>
ssize_t read(int filedes, void *buf, size_t nbytes);
```

Возвращает количество прочитанных байт, 0 &mdash; если достигнут конец файла, -1 в случае ошибки.

Существует несколько ситуаций, когда количество фактически прочитанных байт меньше, чем было запрошено:
* При чтении из обычного файла, когда конец файла встретился до того, как было прочитано требуемое количество байт. Например, если до конца файла осталось 30 байт, а запрошено было 100 байт, то функция read вернет число 30. При следующем вызове она вернет 0 (конец файла).
* При чтении с терминального устройства. Обычно за одно обращение читается одна строка
* При чтении данных из сети. Промежуточная буферизация в сети может стать причиной того, что будет получено меньшее количество байт, чем было запрошено.
* При чтении из именованных или неименованных каналов. Если в канале содержится меньше байт, чем было запрошено, функция read вернет только то, что ей будет доступно.
* При чтении c устройства, ориентированного на доступ к отдельным записям. Примером такого устройства является накопитель на магнитной ленте, который может вернуть только одну запись за одно обращение.
* При прерывании операции чтения сигналом в тот момент, когда часть данных уже была прочитана. 

Операция чтения начинается с текущей позиции файла. В случае успеха текущая позиция будет увеличена на число фактически прочитанных байт.

Корректная программа должна уметь обрабатывать ситуации, когда `read`
считал данных меньше, чем размер буфера. В зависимости от
задачи программа либо пытается дочитать данные до конца,
либо должна сразу приступить к обработке считанной порции данных.

### Системный вызов `write`

```c
include <unistd.h>
ssize_t write(int filedes, const void *buf, size_t nbytes);
```

Возвращает количество записанных байт в случае успеха, -1 в случае ошибки

Возможна ситуация (хотя она намного более редка, чем "короткие" чтения),
что системный вызов `write` запишет данные частично.
Корректная программа должна обрабатывать ситуации, когда системный
вызов `write` записал не весь буфер. Обычно в таких ситуациях
требуется перезапустить `write` на остаток буфера.

### Поддержка больших файлов

На некоторых 32-битных операционных системах по умолчанию размер
файла ограничен $2^31-1$ (2GiB - 1). Попытка открыть или создать
файл большего размера будет диагностирована как ошибка.
На таких системах тип `off_t` объявлен как синоним типа `long`.

Чтобы работать с файлами большого размера при компиляции
программы нужно указать опцию `-D_FILE_OFFSET_BITS=64`.
В этом случае `off_t` будет объявлен как синоним типа `long long`.

# Дополнительный материал

## Компиляция программ без стандартной библиотеки Си

При компиляции программ с помощью драйвера gcc по умолчанию при компоновке программы подключается стандартная библиотека
языка Си libc. Частью стандартной библиотеки является код инициализации (start-up code), который
выполняет необходимую инициализацию стандартной библиотеки (например, создает стандартные потоки stdin, stdout, stderr),
а затем вызывает функцию `main`. Поэтому, если используется стандартная библиотека Си, точкой входа в программу
является функция `main`.

Чтобы отключить стандартную библиотеку можно использовать опцию `-nostdlib`. В этом случае к программе не подключается
код инициализации и код функций стандартной библиотеки. Программа остается "один на один" с операционной системой.
В этом случае точка входа в программу называется `_start` (на Linux). Ядро передает управление на точку `_start` не
как вызов подпрограммы, то есть для завершения программы нельзя использовать инструкцию `ret`. Для завершения
программы нужно использовать системный вызов `exit`.

Таким образом, чтобы скомпилировать 32-битную программу без стандартной библиотеки потребуется командная строка:
```shell script
gcc -m32 -nostdlib prog.S -o prog
```

## Аргументы командной строки и переменные окружения

Перед передачей управления на точку входа `_start` ядро ОС размещает аргументы командной строки и переменные окружения в области памяти, отведенной под стек.
Если, например, верхняя граница адресного пространства, отведенного под стек, равна `0xc0000000`, то непосредственно ниже этой верхней границы будут размещены аргументы
командной строки и переменные окружения. В регистре `%esp` при входе в программу будет находиться текущая верхушка стека, растущего вниз. Начиная от значения `%esp`
на момент старта программы и до верхней границы адресного пространства, отведенного под стек, и будут располагаться аргументы командной строки и переменные окружения.

Так как адрес возврата на стеке отсутствует, по адресу `(%esp)` находится параметр `argc` --- 32-битное целое число, равное числу аргументов командной строки, включая имя программы.
По адресу `%esp + 4` начинается массив `argv` аргументов командной строки, который завершается нулевым указателем. Таким образом, `4(%esp)` --- это `argv[0]`, `8(%esp)` --- это `argv[1]`
`12(%esp)` --- это `argv[2]` и так далее. Если в регистр `%eax` поместить параметр `argc`, то по адресу `4(%esp, %eax, 4)` всегда будет находится нулевой указатель, обозначающий
конец аргументов командной строки. Следующий после него элемент --- это первая строка из массива переменных окружения. Массив переменных окружения завершается нулевым указателем.

Таким образом, в точке входа в программу значения указателей `argv` и `envp` могут быть вычислены следующим образом:

```asm
        mov     (%esp), %eax            // помещаем параметр argc в %eax
        lea     4(%esp), %ecx           // в регистре %ecx будет находиться адрес начала массива аргументов командной строки
        lea     8(%esp, %eax, 4), %edx  // в регистре %edx будет находиться адрес налала массива переменных окружения
```

Передать управление функции `main`, принимающей параметры argc, argv и envp можно будет следующим образом:

```asm
        and     $-16, %esp              // выравнивание стека
        push    %eax                    // для выравнивания области параметров по 16 байт
        push    %edx                    // envp
        push    %ecx                    // argv
        push    %eax                    // argc
        call    main
        add     $16, %esp
```

## Интерфейс системных вызовов

Способ выполнения системного вызова сильно отличается на разных платформах. На платформе x86 системный вызов
выполняется следующим образом:
* номер системного вызова помещается в регистр `%eax`
* параметры системного вызова помещаются в регистры `%ebx`, `%ecx`, `%edx`, `%esi`, `%edi` (в зависимости от их количества)
* выполняется инструкция `int $0x80`

Номера системных вызовов находятся в заголовочном файле `<asm/unistd_32.h>`. Например, чтобы считать один символ со стандартного
потока ввода нужно выполнить системный вызов:
```c
char c;
int val = read(0, &c, sizeof(c));
```

соответствующий фрагмент программы на ассемблере будет выглядеть следующим образом:
```asm
#include <asm/unistd_32.h>
        .data                   // размещаем данные
c:      .byte   0               // c - это глобальная переменная размера один байт (char)
        .text                   // начинаем секцию кода
        // ...
        movl    $__NR_read, %eax // или $3, %eax, если заголовочный файл не найден
        movl    $0, %ebx        // первый аргумент (0 - стандартный поток ввода) в %ebx
        movl    $c, %ecx        // второй аргумент (адрес переменной c) в %ecx
        movl    $1, %edx        // третий аргумент (размер переменной c) в %edx
        int     $0x80
        // в %eax будет возвращаемое значение read
```

системный вызов `exit(0);` на ассемблере запишется следующим образом:
```asm
        movl    $__NR_exit, %eax
        xorl    %ebx, %ebx
        int     $0x80
```

если файл `<asm/unistd_32.h>` недоступен, можно использовать численные значения:
```c
#define __NR_exit 1
#define __NR_read 3
#define __NR_write 4
#define __NR_brk 45
```

## Встроенный ассемблер компилятора gcc

Компиляторы языков Си и Си++ в составе GCC позволяют вставлять инструкции языка ассемблера в тело функции на языке высокого уровня.
В ассемблерной вставке можно использовать специальные символы подстановки, которые будут заменены на аргументы из языка высокого уровня.

Ассемблерная вставка имеет вид:
```
    asm(TEMPLATE : OUTPUTS : INPUTS : CLOBBERS);
```

Элементы внутри скобок разделяются символом ':' (двоеточие). OUTPUTS, INPUTS или CLOBBERS могут отсутствовать. Если пропускается
элемент в конце конструкции, то лишние ':' можно не писать.

TEMPLATE - это строка-шаблон, в которой специальные символы подстановки начинаются со знака '%' (процент). Если символ процента
нужен в самой ассемблерной вставке, его нужно записать дважды. То есть, для записи имени регистра процент нужно указать дважды.
Шаблон записывается по правилам записи строки в Си, если шаблон содержит несколько инструкций, их можно разделить символом \n.
Например,
```c
    asm("movl $1, %%eax\n"
        "movl globvar, %%edx\n"
        "addl %%edx, %%eax\n"
        "movl %%eax, globvar\n");
```

Встроенного ассемблера, который не взаимодействует с объемлющей этот фрагмент функцией на языке высокого уровня,
как правило, достаточно только для самых тривиальных случаев.

Для получения результата вычислений, передачи параметров и спецификации побочных эффектов используются элементы OUTPUTS, INPUTS, CLOBBERS.

В элементе CLOBBERS перечисляются регистры процессора, которые используются в фрагменте на ассемблере. Как следствие,
компилятор не предполагает, что значение этих регистров осталось неизменным. Для фрагмента на ассемблере, приведенного выше,
следует добавить спецификацию используемых регистров следующим образом:
```
    asm("movl $1, %%eax\n"
        "movl globvar, %%edx\n"
        "addl %%edx, %%eax\n"
        "movl %%eax, globvar\n" : : : "%eax", "%edx");
```

Каждый используемый регистр записывается в символьной строке, строки разделяются запятой.

В элементе OUTPUTS перечисляются спецификации для сохранения результата вычисления.
Спецификация имеет вид `SPEC (LVALUE)`. Здесь SPEC - это строка, специфицирующая способ доступа,
LVALUE - адресуемое выражение языка высокого уровня, в которое будет сохранен результат вычисления.
В частности, спецификация "=g" означает, что на месте LVALUE может находиться любое адресуемое
выражение языка Си, и это LVALUE будет модифицировано. Например, спецификация `"=g" (x)`
означает, что результат вычисления будет записан в переменную `x`.
Спецификация `"+g"` означает, что LVALUE будет и считано, и записано.

Использование спецификаций записывается в виде `%N`, где N - последовательный номер спецификации,
начиная с 0, в списке спецификаций OUTPUTS и INPUTS. То есть, первая спецификация OUTPUTS записывается
в ассемблерной вставке как `%0`. Например, следующий фрагмент сохраняет результат вычисления
выражения не в глобальную переменную `globvar`, а в локальную переменную `result`.

```c
    int result;
    asm("movl $1, %%eax\n"
        "movl globvar, %%edx\n"
        "addl %%edx, %%eax\n"
        "movl %%eax, %0\n" : "=g" (result) : : "%eax", "%edx");
```

В элементе INPUTS перечисляются спецификации входных параметров для ассемблерной вставки.
Спецификация имеет вид `SPEC (RVALUE)`. Здесь SPEC - это строка, специфицирующая способ доступа,
RVALUE - выражение языка высокого уровня, значение которого будет передано в ассемблерную вставку.
Спецификация "g" означает, что на месте RVALUE может находиться более-менее любое выражение.

Модифицируем предыдущий пример, чтобы вместо глобальной переменной `globvar` использовалось
заданное выражение.

```c
    int param;
    int result;
    asm("movl $1, %%eax\n"
        "movl %1, %%edx\n"
        "addl %%edx, %%eax\n"
        "movl %%eax, %0\n" : "=g" (result) : "g" (param * 10) : "%eax", "%edx");
```

Если в OUTPUTS указана одна спецификация, она в ассемблерной вставке используется как `%0`.
Тогда спецификации из INPUTS будут обозначаться как `%1`, `%2`, ...

## Ссылки

1. [GCC Documentation](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)
