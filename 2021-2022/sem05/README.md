# Работа со временем

В операционных системах в дальнейшем мы будем различать два вида
времени: астрономическое (календарное), согласованное с временем
в физическом мире, и виртуальное, отсчитываемое независимо
для каждого процесса.

В операционных системах семейства
[UNIX астрономическое (календарное) время](https://en.wikipedia.org/wiki/Unix_time)
 измеряется как число секунд, прошедших с некоторой точки отсчета,
называемой "началом эпохи" (epoch). В Unix началом эпохи
считается полночь 1 января 1970 года по всемирному
координированному времени [(UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).

Для простоты отсчет времени игнорирует "високосные секунды" [(leap seconds)](https://en.wikipedia.org/wiki/Leap_second).
Поэтому в каждых сутках всегда 86400 секунд.

Для хранения времени во внутреннем формате предназначен тип `time_t`.
Это &mdash; знаковый тип, с помощью него можно хранить и отметки времени ранее начала эпохи,
которые будут представляться отрицательными числами.
Значению &minus;1 соответствует момент времени 23:59:59 31 декабря 1969 года,
но некоторые функции используют значение &minus;1 в качестве специального
значения-признака ошибки, поэтому чтобы различить допустимый момент
времени и специальное значение-признак ошибки потребуется проверить значение
переменной `errno`.

Часто на 32-битных версиях операционных систем семейства UNIX
тип `time_t` является синонимом типа `long`, то есть 32-битным
знаковым целым типом. Знаковые 32 бита для хранения счетчика секунд
дают диапазон представимых дат от начала XX века до 2038 года.
В 03:14:07 19 января 2038 32-битный счетчик секунд достигнет
максимального значения (`INT_MAX`), что называется
[проблемой 2038 года](https://en.wikipedia.org/wiki/Year_2038_problem).

На 64-битных операционных системах проблема переполнения не актуальна,
так как 64-битного счетчика секунд достаточно, чтобы покрыть
все [предполагаемое время жизни Солнечной системы](https://en.wikipedia.org/wiki/Timeline_of_the_far_future).

## Получение астрономического времени

Функция `time` возвращает текущее время и дату.

```c
#include <time.h>
time_t time(time_t *calptr);
```

Функция возвращает текущее время.
Если в качестве параметра `calptr` передается ненулевой указатель,
то же самое значение текущего времени записывается по указателю.

Функция `gettimeofday` позволяет получить текущее время с микросекундной точностью.

```c
#include <sys/time.h>
int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
```

Функция всегда возвращает значение 0. Параметр `tzp` должен всегда
передаваться как нулевой указатель.

Функция `gettimeofday` сохраняет время, прошедшее от начала Эпохи до настоящего момента,
по адресу `tp`. Это время представлено в виде структуры `timeval`,
 которая хранит секунды и микросекунды:

```c
struct timeval
{
    time_t tv_sec; /* секунды */
    long   tv_usec; /* микросекунды */
};
```

## Работа с календарем

Стандартная библиотека Си и UNIX поддерживает только [Грегорианский календарь](https://en.wikipedia.org/wiki/Gregorian_calendar).
Если требуется обработка календарной информации в других календарях,
потребуются сторонние библиотеки.

Для хранения момента времени в Грегорианском календаре
используется структура `tm`, определенная следующим образом:

```c
struct tm /* время, разбитое на составляющие */
{ 
    int tm_sec; /* секунды от начала минуты: [0 - 60] (note leap seconds) */
    int tm_min; /* минуты от начала часа: [0 - 59] */
    int tm_hour; /* часы от полуночи: [0 - 23] */
    int tm_mday; /* дни от начала месяца: [1 - 31] */
    int tm_mon; /* месяцы с января: [0 - 11] */
    int tm_year; /* годы с 1900 года */
    int tm_wday; /* дни с воскресенья: [0 - 6] */
    int tm_yday; /* дни от начала года (1 января): [0 - 365] */
    int tm_isdst; /* флаг перехода на летнее время: <0 - unknown, 0 - no daylight saving, >0 - daylight saving */
};
```

Количество секунд может превышать 59, когда для коррекции времени вставляется дополнительная секунда.
Обратите внимание, что отсчет всех компонентов, кроме дня месяца, начинается с 0.
 лаг перехода на летнее время представлен положительным числом, если действует летнее время,
 0 – если нет и отрицательным числом, если данная информация недоступна или неизвестна.

### Функции `gmtime_r`, `localtime_r`

Для получения календарной даты по значению типа `time_t` следует использовать
функции `gmtime_r` или `localtime_r`.

```c
#include <time.h>
struct tm *gmtime_r(const time_t *calptr, struct tm *result);
struct tm *localtime_r(const time_t *calptr, struct tm *result);
```

Функция `gmtime_r` выдает календарную дату по UTC, а функция `localtime_r`
выдает календарную дату в локальном часовом поясе. В качестве параметра `result`
должен быть передан указатель на структуру, которая будет заполнена.
Этот же указатель будет возвращен в качестве результата работы функций.

Обратите внимание, что год в поле `tm_year` отсчитывается от 1900, а месяц - от 0.
Поэтому, чтобы, например, вывести дату в формате YYYY-MM-DD потребуется
прибавить соответствующие значения:
```c
    printf("%04d-%02d-%02d", r->tm_year + 1900, r->tm_mon + 1, r->tm_mday);
```

### Функции `timegm`, `mktime`

Обратное преобразование из календарной даты в тип `time_t`
выполняют следующие функции:

```c
#include <time.h>
time_t timegm(struct tm *tmptr);
time_t mktime(struct tm *tmptr);
```

Первая функция предполагает, что календарная дата записана по UTC,
а вторая, что в локальной временной зоне.

В случае ошибки эти функции возвращают &minus;1, что является и допустимым
временем. Чтобы различить нормальный и ошибочный результат потребуется
привлечь переменную `errno`.

```c
    errno = 0;
    time_t res = mktime(&val);
    if (res == -1 && errno) { /* conversion failed */ }
```

Перед вызовом функций `mktime` или `timegm` нужно заполнить 6 полей структуры `tm`,
которые задают момент времени: `tm_year` (год), `tm_mon` (месяц), `tm_mday` (день месяца),
`tm_hour` (час), `tm_min` (минуты), `tm_sec` (секунды).
В поле `tm_isdst` обязательно нужно записать значение &minus;1.

В качестве побочного эффекта эти функции заполняют оставшиеся
поля структуры `tm`, включая и поле `tm_isdst`, а кроме того,
нормализуют переданные им значения основных полей времени. Так,
время 25:11:04 33 декабря 2020 года будет преобразовано
в 01:11:04 3 января 2021 года, и значения основных полей будут
соответствующим образом изменены. 

### Функция `strftime`

Функция `strftime` выполняет форматное преобразование из структуры `tm`
в строку. Форматное преобразование задается строкой,
аналогичной форматной строке функций типа `printf`.

```c
#include <time.h>
size_t strftime(char *buf, size_t maxsize, const char *format, const struct tm *tmptr);
```

Возвращает количество символов, записанных в массив,
если в нем достаточно места, в противном случае возвращает 0

Последний аргумент функции – указатель на структуру `tm`, содержащую время,
которое должно быть представлено в виде отформатированной строки. 
Результат форматирования сохраняется в буфере `buf`,
размер которого определяется аргументом `maxsize`.
Аргумент `format` управляет форматированием значения времени.
Как и в случае с функцией `printf`, спецификаторы формата начинаются с символа процента,
за которым следуют служебные символы.
Все остальные символы в строке `format` выводятся без изменений.
Два символа процента, следующие друг за другом, будут отображаться как один символ процента.
В отличие от функции `printf`, каждый спецификатор формата генерирует на выходе строки
фиксированного размера – спецификаторы ширины поля вывода не предусмотрены.
 
Если полученная в результате преобразования строка, включая завершающий нулевой символ,
умещается в буфере, то функция возвращает длину полученной строки без завершающего нулевого символа.
В противном случае возвращается 0.

# Работа с каталогами.

Создание каталогов производится с помощью функции `mkdir`, а удаление &mdash; с помощью функции `rmdir`.

```c
#include <sys/stat.h>

int mkdir(const char *pathname, mode_t mode);
```

Возвращает 0 в случае успеха, –1 в случае ошибки.
Если запись с таким именем уже существует, функция завершается с ошибкой.
В случае успеха права на создаваемый каталог выставляются с учетом параметра `umask`
процесса (то есть `mode & ~umask`).

```c
#include <unistd.h>

int rmdir(const char *pathname);
```

## Просмотр каталога

Для просмотра каталога используются функции, определенные
в заголовочном файле `<dirent.h>`.

В данном случае стандартный API предоставляет пользователям высокоуровневый
интерфейс, аналогичный интерфейсу `FILE` стандартной библиотеки.
Какие системные вызовы используются для реализации интерфейса `DIR`
не специфицируется.

```c
#include <dirent.h>

DIR *opendir(const char *pathname);
struct dirent *readdir(DIR *dp); 
int closedir(DIR *dp);

long telldir(DIR *dp); 
void seekdir(DIR *dp, long loc);
```

### Функции `opendir`, `closedir`

Функция `opendir` открывает каталог по заданному пути.
В случае успеха возвращается указатель на структуру `DIR`
хранящую состояние открытого каталога. В случае неудачи
функция `opendir` возвращает нулевой указатель.

Функция `closedir` закрывает открытый каталог и освобождает
все ресурсы, связанные с открытым каталогом (это обычно
один файловый дескриптор и одна область динамической памяти).

### Функция `readdir`

Функция `readdir` возвращает очередную запись в открытом каталоге.

Структура `dirent` определена в файле `<dirent.h>` и зависит от конкретной реализации.
Однако в любой версии UNIX эта структура содержит как минимум следующие два поля:

```c
struct dirent
{
    ino_t d_ino;               /* номер индексного дескриптора */
    char d_name[NAME_MAX + 1]; /* строка имени файла, завершающаяся нулевым символом */
}
```

Поле `d_ino` использовать нельзя, так как в точках монтирования оно содержит
локальное для текущей файловой системы значение и не позволит связать
файловые системы в единое дерево. Если нужен номер индексного дескриптора
записи в каталоге, следует использовать системный вызов семейства `stat`.

Поле `d_name` содержит имя очередной записи в каталоге. Значение константы
`NAME_MAX` обычно равно 255, то есть API работы с каталогами UNIX не поддерживает
работу с файлами, если длина имена файла в каком-либо каталоге превышает
255 байтов, даже если и файловая система сама по себе поддерживает
более длинные имена.

Функция `readdir` возвращает указатель куда-то вовнутрь состояния
открытого каталога (структуры `DIR`). Значение этого указателя
становится недействительным после следующего вызова `readdir`,
или в результате вызова `closedir`. Поэтому, если значение поля `d_name`
может потребоваться в дальнейшем, его нужно скопировать в другую область памяти.

### Функции `telldir`, `seekdir`

Хотя в API определены функции `telldir` и `seekdir`, которые, по идее,
позволяют запомнить текущее положение в каталоге и вернуться к нему позднее,
например, после выхода из рекурсии, работоспособность такого подхода не гарантируется.
Значение, возвращенное функцией `telldir`, становится недействительным,
если каталог был закрыт. При повторном открытии каталога вызов `telldir`
на той же самой позиции может вернуть другое значение. Поэтому
функции `telldir` и `seekdir` нельзя применять для рекурсивного обхода
файловой системы.

Поэтому чтобы рекурсивно обойти файловую систему для каждого каталога в
иерархии каталогов следует считать все его содержимое в память
однократым проходом по каталогу с помощью `opendir`/`readdir`/`closedir`,
после чего обработать список файлов, сохраненный в памяти, рекурсивно
обрабатывая подкаталоги.

### Функции `chdir`, `fchdir`

Для каждого процесса определен текущий рабочий каталог.
относительно этого каталога вычисляются все относительные пути (то есть пути, которые не начинаются с символа слэша).
Когда пользователь входит в систему, текущим рабочим каталогом обычно становится каталог, указанный в шестом поле записи из файла /etc/passwd, – домашний каталог пользователя. Текущий рабочий каталог – это атрибут процесса, домашний каталог – атрибут пользователя.
Процесс может изменить текущий рабочий каталог с помощью функции `chdir` или `fchdir`.

```c
#include <unistd.h>

int chdir(const char *pathname);
int fchdir(int filedes); 
```

Функции возвращают 0 в случае успеха, –1 в случае ошибки.

Пример использования функции `chdir`

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    if (chdir("/tmp") < 0) {
        fprintf(stderr, "ошибка вызова функции chdir: %s\n", strerror(errno));
        exit(1);
    }
    printf("каталог /tmp стал текущим рабочим каталогом\n");
    exit(0);
}
```

### Функция `getcwd`

Поскольку ядро хранит сведения о текущем рабочем каталоге, должен быть способ получить его текущее значение. К сожалению, ядро хранит не полный путь к каталогу, а некоторую иную информацию, такую как указатель
на виртуальный узел (v-node) каталога.
Чтобы определить абсолютный путь к текущему рабочему каталогу, нужна функция, которая будет перемещаться вверх по дереву каталогов, начиная с текущего («точка») и далее через специальные каталоги «точка - точка»,пока не достигнет корневого каталога. В каждом из промежуточных каталогов функция будет читать записи из файла каталога, пока не найдет название, которое соответствует индексному узлу предыдущего каталога. Повторяя эту процедуру до тех пор, пока небудет достигнут корневой каталог, мы в результате получим абсолютный путь к текущему рабочему каталогу.
К счастью, такая функция уже существует.

```c
#include <unistd.h>

char *getcwd(char *buf, size_t size);
```

Функция озвращает указатель на `buf` в случае успеха, `NULL` в случае ошибки.

Пример использования функции `getcwd`.

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
    char *ptr;
    size_t size = PATH_MAX;

    if (chdir("/usr/spool/uucppublic") < 0) {
        fprintf(stderr, "ошибка вызова функции chdir: %s\n", strerror(errno));
        exit(1);
    }

    if (!(ptr = malloc(size))) {
        fprintf(stderr, "ошибка выделения памяти: %s\n", strerror(errno));
        fflush(NULL);
        abort();
    }

    if (getcwd(ptr, size) == NULL) {
        fprintf(stderr, "ошибка вызова функции getcwd: %s\n", strerror(errno));
        exit(1);
    }

    printf("cwd = %s\n", ptr);
    exit(0);
}
```

