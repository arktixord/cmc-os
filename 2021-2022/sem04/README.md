# Файлы и каталоги

## Функции stat, fstat и lstat

```c
#include <sys/types.h>
#include <sys/stat.h>

int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
```
Системный вызов `stat` возвращает структуру с информацией о файле, указанном в аргументе `pathname`.
Функция `fstat` возвращает информацию об открытом файле, который определяется дескриптором `filedes`. 
Функция `lstat` похожа на функцию `stat`, но когда ей передается имя символической ссылки, она возвращает сведения о самой символической ссылке, а не о файле, на который она ссылается.
Второй аргумент, `buf`, является указателем на структуру, которую функция будет заполнять информацией. Определение структуры может отличаться для разных реализаций, но основная ее часть выглядит следующим образом:

```c
struct stat {
    mode_t st_mode;   /* тип файла и режим (права доступа) */
    ino_t st_ino;     /* номер индексного узла */
    dev_t st_dev;     /* номер устройства (файловой системы) */
    dev_t st_rdev;    /* номер устройства для специальных файлов */
    nlink_t st_nlink; /* количество ссылок */
    uid_t st_uid;     /* идентификатор пользователя владельца */
    gid_t st_gid;     /* идентификатор группы владельца */
    off_t st_size;    /* размер в байтах, для регулярных файлов */
    time_t st_atime;  /* время последнего обращения к файлу */
    time_t st_mtime;  /* время последнего изменения файла */
    time_t st_ctime;  /* время последнего изменения флагов состояния файла */
};
```
## Типы файлов

1. Регулярный файл – наиболее распространенный тип файлов, который хранит данные в том или ином виде.
Ядро UNIX не делает различий между текстовыми и двоичными файлами.
Любая интерпретация содержимого файла полностью возлагается на прикладную программу,
обрабатывающую файл.
2. Файл каталога. Файлы этого типа содержат имена других файлов и ссылки на информацию о них. Любой процесс, обладающий правом на чтение
каталога, может проверить его содержимое, но только ядро обладает правом на запись в файл каталога. Чтобы внести изменения в каталог, про 
цессы должны пользоваться функциями работы с каталогами.
3. Специальный файл блочного устройства. Этот тип файлов обеспечивает буферизованный ввод вывод для таких устройств, как дисковые устрой 
ства с фиксированным размером блока.
4. Специальный файл символьного устройства. Этот тип файлов обеспечивает небуферизованный ввод вывод для устройств с переменным размером
блока. Все устройства в системе являются либо специальными файлами блочных устройств, либо специальными файлами символьных устройств.
5. FIFO, или именованный канал. Этот тип файлов используется для организации обмена информацией между процессами. 
6. Сокет. Этот тип файлов используется для организации обмена между процессами. 
7. Символическая ссылка. Файлы этого типа представляют собой ссылки на другие файлы.

Тип файла хранится в поле st_mode структуры stat. Определить тип файла можно с помощью макроопределений, приведенных ниже 
(Макросы для определения типа файла из  ```<sys/stat.h>```)

 * `S_ISREG(st_mode)` Регулярный файл
 * `S_ISDIR(st_mode)` Каталог
 * `S_ISCHR(st_mode)` Специальный файл символьного устройства
 * `S_ISBLK(st_mode)` Специальный файл блочного устройства
 * `S_ISFIFO(st_mode)` Канал (именованный или неименованный)
 * `S_ISLNK(st_mode)` Символическая ссылка
 * `S_ISSOCK(st_mode)` Сокет

## Системный вызов access

```c
#include <unistd.h>

int access(const char *pathname, int mode);
```

Проверяет, какие операции с файлом по данному пути процесс может выполнить. Симлинки разыменовываются. Что можно проверить (флаги в mode, можно комбинировать через побитовое или):

* `F_OK` - просто факт существования
* `R_OK` - файл можно читать
* `W_OK` - в файл можно писать
* `X_OK` - файл можно исполнить

В случае успеха (всё, что спрашивалось, можно) вызов возвращает 0. В противном случае (в том числе, в случае ошибки) вызов возвращает -1 и выставляет errno в соответствии с причиной отказа.
Функция `access` проверяет права доступа к файлу в соответствии с реальным, а не
эффективным идентификатором пользователя, с правами которого
выполняется процесс. Поэтому привилегированный процесс, то есть процесс,
у которого эффективный идентификатор пользователя отличается от реального
идентификатора пользователя, может использовать этот системный вызов
для проверки возможности доступа к указанному файлу с точки
зрения пользователя, запустившего данный процесс.

# Привилегии процесса (традиционная модель)

Идентификатор пользователя - это беззнаковое число, использующееся
в ядре операционной системы для идентификации пользователя.
Идентификатор пользователя используется для
авторизации пользователя на выполнение различных действий.
Отображение строковых идентификаторов в числовые
можно найти в файле `/etc/passwrd`. Но кроме того
это отображение может предоставляться различными системными сетевыми
сервисами, подобными openldap.

Идентификатор группы - это беззнаковое число, использующееся
для идентификации группы, к которой относится пользователь.

Пользователь с идентификатором 0 считается суперпользователем.
Он может выполнить любую операцию, за исключением запуска файла без
установленного бита `x`.

Реальный идентификатор пользователя процесса - идентификатор
пользователя, который запустил данный процесс.
Эффективный идентификатор пользователя процесса - идентификатор
пользователя, который используется при проверке прав доступа
на выполненение различных операций.

В обычной ситуации (непривилегированный процесс) реальный идентификатор
пользователя совпадает с эффективным идентификатором пользователя.
Это значит, что права исполняемого файла определяются правами
пользователя, который его запустил.
