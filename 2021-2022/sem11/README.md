# Сигналы

Сигналы &mdash; это программный механизм уведомления процесса о событии
возникшем в ходе выполнения самого процесса, других процессов или
ядра операционной системы. Сигналы по концепции аналогичны механизму
аппаратных прерываний (по образцу которых, видимо, и были спроектированы).
Это значит, что сигнал может поступить в процесс в любой момент времени,
выполнение текущей инструкции процессора будет завершено,
и управление будет передано на специальную функцию-обработчик сигнала.
После завершения функции-обработчика выполнение вернется
к той точке программы, на которой оно было прервано приходом сигнала.
Поэтому говорят, что сигналы являются "асинхронными" событиями,
то есть их возникновение никак не синхронизировано с ходом работы
процесса.

Но в некоторых случаях получения сигнала является "синхронным" событием,
то есть немедленно следует за каким-то действием самого процесса.
Например, отправка любого сигнала самому себе &mdash; синхронна, то есть
для вызова

```c
    kill(getpid(), signo);
```

гарантируется, что обработчик указанного сигнала отработает до того,
как завершится системный вызов `kill`.
Другой пример синхронного получения сигнала &mdash; это реакция
процессора и ядра операционной системы на ошибку при выполнении
инструкции процессора. Например, в случае некорректного обращения
процесса к памяти ядро посылает процессу сигнал `SIGSEGV`,
прервав выполнение процесса на проблемной инструкции процесса.

С другой стороны, любой сигнал, отправленный одним процессом другому
процессу, даже тот же самый `SIGSEGV`, является асинхронным.

Список всех типов сигналов в системе можно получить
с помощью команды `kill -l` командного процессора bash. На современном
Linux он такой:

```
[user@host ~]$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```

Мы видим, что всего поддерживается 64 типа сигнала, из которых сигналы с номерами
от 1 (`SIGHUP`) до 31 (`SIGSYS`) имеют индивидуальные имена и используется
каждый для какой-то своей цели. Они называются "стандартными" сигналами.
Сигналы с номерами от 34 (`SIGRTMIN`) до 64 (`SIGRTMAX`) не имеют
индивидуального назначения и называются "сигналами реального времени".
Работа с ними немного отличается от работы с обычными сигналами.
Всего поддерживается 64 разных номера сигнала, то есть для представления
множеств сигналов достаточно 64-битного целого числа. Такое число,
хранящее номера сигналов по одному биту на сигнал, называется
"маска сигналов".

Соответствие имен сигналов (`SIGINT`, `SIGSEGV`, ...) их номерам определено
в заголовочном файле `<signal.h>`. В программе на Си всегда должны
использоваться эти идентификаторы, а не номера сигналов, которые
могут варьироваться в зависимости от операционной системы и
процессорной архитектуры.

Если рассмотреть, в какой ситуации возникает тот или иной сигнал,
то стандартные сигналы могут быть классифицированы по происхождению
следующим образом.

* Отправляемые при наступлении событий на терминале, к которому привязан процесс:
`SIGHUP`, `SIGINT`, `SIGQUIT`, `SIGTSTP`, `SIGTTIN`, `SIGTTOU`, `SIGWINCH`.

* Отправляемые ядром ОС как реакция на действия самого процесса:
`SIGILL`, `SIGTRAP`, `SIGBUS`, `SIGFPE`, `SIGKILL` (в ряде случаев),
`SIGSEGV`, `SIGPIPE`, `SIGSTKFLT`, `SIGSYS`, `SIGXFSZ`.

* Отправляемые при срабатывании таймера:
`SIGALRM`, `SIGVTALRM`, `SIGPROF`, `SIGXCPU`.

* События ввода-вывода:
`SIGURG`, `SIGIO`.

* Сигналы межпроцессного взаимодействия:
`SIGKILL`, `SIGTERM`, `SIGCHLD`, `SIGUSR1`, `SIGUSR2`.

* Приостановка и продолжение выполнения процесса:
`SIGSTOP`, `SIGCONT`.

* Отладка:
`SIGABRT`.

* Прочее:
`SIGPWR`.

В первую очередь нас будут интересовать сигналы `SIGINT`, `SIGKILL`,
`SIGALRM`, `SIGTERM`, `SIGUSR1`, `SIGUSR2`.

Подробное описание каждого сигнала доступно здесь.

## Реакция на сигнал

Когда программа только начинает работу, обработка сигналов обычно
никак не настроена. Если сигнал поступит в процесс, он будет обрабатываться
в режиме "по умолчанию" (`SIG_DFL`). Как именно обрабатывается
сигнал по умолчанию зависит от самого сигнала. Возможны следующие варианты:

* Не делать ничего (обозначается `Nop`). Когда сигнал поступает в процесс,
он считается обработанным. Если процесс выполнялся, он продолжит
выполняться. Но если процесс находился в ожидании
поступления сигнала, например, с помощью системного вызова `pause`,
системный вызов завершает работу, и управление возвращается в
пользовательский код процесса.

* Завершить процесс (обозначается `Term`). Ядро ОС снимает процесс
с выполнения, уничтожает его и освобождает все его ресурсы.
Родитель завершившегося процесса может узнать о том, что
процесс завершился из-за сигнала, используя макрос
`WIFSIGNALED`, а номер сигнала получить с помощью макроса
`WTERMSIG`. Сам процесс изнутри не отслеживает момент завершения
по сигналу, он просто перестает существовать. Естественно,
никакие деструкторы, обработчики `atexit` не вызываются.

* Аварийно завершить процесс (обозначается `Core`). Отличие от
предыдущего случая в том, что ядро ОС еще сохраняет состояние
виртуальной памяти процесса перед его уничтожением. Традиционно
состояние памяти сохранялось в файл `core` (отсюда приписка
`(core dumped)` в выводе командного интерпретатора,
запустившего аварийно завершившуюся программу), но сейчас выбор опций,
куда сохраняется содержимое виртуального адресного пространства
намного богаче.

* Приостановить выполнение процесса (обозначается `Stop`).
Процесс переводится в специальное приостановленное состояние,
в котором он может находиться неограниченное время.
В приостановленном состоянии все ресурсы процесса остаются за ним,
но приостановленный процесс считается не готовым к выполнению,
поэтому никогда не получит процессорное время.

Если процесс находится в приостановленном состоянии и получает сигнал,
который не игнорируется и либо обрабатывается по умолчанию в режиме
`Nop`, `Term` или `Core`, либо обрабатывается процессом,
сигнал помечается "ожидающим доставки" до момента,
когда выполнение процесса будет возобновлено.

* Возобновить выполнение процесса (обозначается `Cont`).
Этот тип обработки применим только к приостановленным процессам
и переводит процесс из состояния приостановленного
в состояние готового к выполнению.

В любой момент времени процесс может восстановить режим обработки
сигнала по умолчанию с помощью вызова

```
    signal(signo, SIG_DFL);
```

### Игнорирование сигнала

Второй вариант обработки сигнала &mdash; игнорирование.
Процесс может настроить игнорирование любого сигнала, кроме
`SIGKILL` и `SIGSTOP`.
Игнорируемые сигналы вообще не отправляются в процесс.
То есть при отправке сигнала процессу с помощью
системного вызова `kill` сначала проверяется,
игнорируется ли данный сигнал, и если это так,
системный вызов на этом завершается.

Игнорирование сигнала активируется с помощью вызова

```
    signal(signo, SIG_IGN);
```

### Обработка сигнала

Третий вариант установки обработки сигнала &mdash; установка
функции-обработчика сигнала. Функция-обработчик будет получать
управление каждый раз, когда в процесс поступает сигнал.
После завершения функции-обработчика управление возвращается
в основную программу в ту точку, в которой выполнение
было прервано сигналом. Базовый вариант функции-обработчика
должен выглядеть следующим образом:

```c
void handler(int s)
{
    // ...
}
```

То есть функция-обработчик не возвращает результат и принимает один
целый аргумент, в который передается номер поступившего сигнала.
Это полезно в случае, когда одна и та же функция-обработчик
используется для нескольких сигналов.

Обработчик сигнала следует устанавливать с помощью системного
вызова `sigaction` следующим образом:

```c
    sigaction(signo, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
```

Здесь `signo` &mdash; это номер сигнала, `handler` &mdash; это функция-обработчкик, `SA_RESTART` &mdash; это флаг вызова обработчика, который полезно иметь установленным при обработке, он будет обсуждаться позднее.
Хотя использование системного вызова `signal` может показаться более простым,
использовать его не стоит, так как он ведет себя по-разному
на разных системах и даже на одной и той же системе при разных
флагах компиляции.

Подробнее обработка сигналов будет рассмотрена ниже.

## Отправка сигнала

Процесс может отправить сигнал себе или другому процессу с
помощью системного вызова `kill`.

```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

Параметр `sig` задает отправляемый сигнал. Причем он может быть равен 0,
тогда никакой сигнал не отправляется, а только проверяется возможность
отправки, то есть существование соответствующего процесса или
группы процессов и доступность для отправки сигнала.

Параметр `pid` указывает, какому процессу (процессам) отправляется сигнал.
* если `pid > 0`, сигнал отправляется процессу с указанным идентификатором
* если `pid == 0`, сигнал отправляется текущей группе процессов, то
есть самому процессу и всем процессам, находящимся в одной группе с ним.
* если `pid == -1`, сигнал отправляется всем процессам в системе,
которым данный пользователь имеет право отправить сигнал. Для обычного
пользователя это, как правило, все процессы в системе, работающие
с идентификатором этого пользователя.
* если `pid < -1`, сигнал отправляется группе процессов с идентификатором
`-pid`.

Как было сказано выше, отправка сигнала самому себе (как с указанием pid,
так и в группу, содержащую данный процесс) синхронна, то есть
гарантируется, от обработчик сигнала отработает до возврата из
системного вызова `kill`. Отправка любого сигнала другому процессу всегда
асинхронна.

В случае успешной отправки системный вызов возвращает 0.
В случае невозможности отправить сигнал системный вызов возвращает -1,
причем возможны следующие ошибки:

* `EINVAL` &mdash; недопустимый сигнал
* `EPERM` &mdash; процесс-отправитель не имеет прав послать сигнал
указанному процессу (группе процессов)
* `ESRCH` &mdash; указанный процесс или группа процессов не существует.

### Этапы отправки сигнала

Обработка сигнала от отправки из одного процесса до получения
в другом процессе состоит из следующих шагов.

* Проверяется, что заданный процесс или группа процессов существует,
если это не так, системный вызов `kill` завершается с ошибкой `ESRCH`.

* Далее для процесса-получателя или всех процессов в группе-получателе
выполняются следующие действия.
** Проверяется, что процесс-отправитель имеет право отправки сигнала
рассматриваемому процессу. В самом простом варианте, идентификаторы пользователя
должны совпадать. Если это не так, системный вызов `kill` завершается с ошибкой `EPERM`.
** Если рассматриваемый процесс игнорирует отправляемый сигнал, обработка сигнала считается завершенной.
** Иначе сигнал добавляется в "маску сигналов, ожидающих доставки" (pending signals) с помощью операции побитового "или". Если сигнал не заблокирован
в процессе (о блокировке сигналов будет ниже), то есть для сигнала
не установлен бит в маске заблокированных сигналов, то процесс ставится
на перепланировку в планировщик процессов. Если процесс находился в состоянии 'S' (sleeping), он переводится в состояние готовности к выполнению 'R' (running).
* Перед завершением системного вызова вызывается планировщик процессов,
который обрабатывает изменение состояния всех затронутых процессов.
Но планировщик может работать параллельно с завершением системного вызова `kill`. То есть когда системный вызов `kill` вернет управление в процесс,
нет никакой гарантии, что другой процесс уже получил этот сигнал.

### Получение сигнала

Для того, чтобы процесс получить сигнал, сначала работает планировщик
процессов в ядре операционной системы. Процесс должен находиться
в состоянии 'R' (running). Как было сказано выше,
сигналы, игнорируемые (`SIG_IGN`) процессом, до этой стадии не доходят.
В маске (то есть битовом множестве размером 64 бита) сигналов,
ожидающих доставки находятся сигналы, которые другие процессы
успели послать рассматриваемому процессу, плюс блокируемые
в текущий момент времени сигналы. Ситуация, когда один процесс
может получить сразу несколько сигналов вполне возможна, так как
отправка сигнала выполняется от имени отправляющего процесса,
а получение от имени получающего процесса, и эти моменты разделены
во времени.

Если из маски сигналов, ожидающих доставки (pending) убрать
заблокированные (blocked) сигналы, останутся сигналы, готовые к доставке.
Эти сигналы могут обрабатываться в произвольном порядке, но обычно
обрабатываются в порядке возрастания номера сигнала (так проще всего).
Если сигнал, готовый к доставке, обрабатывается по умолчанию,
выполняется его обработка, которая обычно заключается в снятии
процесса с выполнения с формированием соответствующего кода завершения.
Если сигнал, готовый к доставке, обрабатывается пользователем,
то ядро готовит стек для запуска пользователькой функции в
процессе, возвращает управление в эту функцию в пользовательском
режиме выполнения процесса, а после завершения функции-обработчика
заново проверяет все сигналы, готовые к доставке. То есть вполне возможно,
что в процессе работы обработчика возникнет тот же самый сигнал
или сигналы с меньшим номером, и тогда они снова будут обработаны
по схеме, описанной выше.

## Проблемы обработки сигналов

Из-за того, что получение сигнала в процесс является асинхронным событием,
корректная обработка получения сигнала имеет ряд тонкостей, которые
необходимо учитывать.

### Проблема асинхронной безопасности

Рассмотрим такой пример:

```c
#include <stdio.h>
#include <signal.h>

void handler(int s)
{
    printf("signal received\n");
}

int main()
{
    int a, b;
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (scanf("%d%d", &a, &b) == 2) {
        printf("%d\n", a + b);
    }
}
```

На каждое получение сигнала `SIGINT`, то есть при нажатии Ctrl-C в терминале
программа выводит `signal received`.

У этой программы есть серьезная проблема. Представим себе, что два числа
успешно считаны, и функция `main` вызвала функцию `printf` для
вывода суммы. Функция `printf` обрабатывает форматную строку,
работает со структурой `FILE` для потока `stdout`, модифицируя в ней поля.
В этот момент приходит сигнал `SIGINT`, выполнение функции `printf`
прерывается и управление передается в `handler`, которая в свою
очередь вызывает `printf`. Возникает ситуация, когда `printf`
еще не доработала до конца и возможно не полностью обновила поля
структуры `FILE`, и она вызывается снова!

Функции, которые корректно работают в таких ситуациях, называются
"реентерабельной" (reentrant). `printf` к таким функциям не относится,
поэтому нет никаких гарантий, что и первый, и второй вызов отработают
корректно и что ни один из них не уронит программу.

В терминологии POSIX-ориентированных систем функция, которую
допустимо вызывать из обработчиков сигналов, называется
"асинхронно-безопасной" (async-signal safe). Если функция
таковой не является, использовать ее в обработчиках сигналов
нельзя. Функции ввода/вывода стандартной библиотеки Си
(`scanf`, `printf` и так далее), функции работы с динамической
памятью не являются асинхронно-безопасными. Список асинхронно-безопасных
функций можно посмотреть с помощью команды `man 7 signal-safety`.
Обратите внимание, что функции `sprintf`, `snprintf` не
являются асинхронно-безопасными!

У этой проблемы два возможных решения:
* не использовать не асинхронно-безопасные функции в обработчиках
сигнала
* гарантировать, что асинхронно-безопасные функции не могут быть
вызваны в основной программе в тот момент, когда вызывается
обработчик сигнала. Самый простой случай, когда в основной программе
асинхронно-безопасных функций вообще нет. В этом случае
обработчик сигнала как бы меняется ролями с основной программой.
Это достижимо в простейших учебных программах, но практически
невозможно в реальных программах.

Поэтому правильный вариант &mdash; не использовать асинхронно-безопасные
функции в обработчиках сигналов. Поэтому в нашей программе
использование `printf` следует заменить на использование `write`,
системного вызова, который асинхронно-безопасный.

```c
#include <stdio.h>
#include <signal.h>

void handler(int s)
{
    static const char msg[] = "signal received\n";
    write(STDOUT_FILENO, msg, sizeof(msg) - 1);
}

int main()
{
    int a, b;
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (scanf("%d%d", &a, &b) == 2) {
        printf("%d\n", a + b);
    }
}
```

Для простоты мы проигнорируем возможность того, что `write`
по какой-то причине запишет в файловый дескриптор 0 только часть строки.
Как бы это не было маловероятно, это вполне возможно. Корректная
запись строки оставляется в качестве упражнения.
Но есть еще проблема с переменной `errno`. Эта переменная &mdash;
глобальная. (Строго говоря, она своя на каждую нить исполнения,
но об этом позже.) Если вдруг системный вызов `write`
завершится с ошибкой и установит в `errno` код ошибки,
этот код ошибки останется в переменной и после завершения
обработчика сигнала. А возможно, что основная программа
в этот момент проверяла `errno` и выполняла какие-то действия
в зависимости от его значения. Чтобы избежать такой ситуации,
нужно сохранять значение `errno` в начале обработчика
и восстанавливать его в конце, как показано в следующей программе.

```c
#include <stdio.h>
#include <signal.h>
#include <errno.h>

void handler(int s)
{
    static const char msg[] = "signal received\n";
    int e = errno;
    write(STDOUT_FILENO, msg, sizeof(msg) - 1);
    errno = e;
}

int main()
{
    int a, b;
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (scanf("%d%d", &a, &b) == 2) {
        printf("%d\n", a + b);
    }
}
```

В этой программе обработчик сигнала реализован корректно.

### Проблема установки глобальных переменных

На практике обработчик сигнала, как правило, устанавливает
значение глобальной переменной-флага. Это один из немногих
случаев, когда без глобальных переменных не обойтись.
Но и в варианте с установкой глобальных переменных
есть несколько тонкостей.

```c
#include <signal.h>
#include <stdio.h>

int flag;

void handler(int s)
{
    flag = 1;
}

int main()
{
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (1) {
        while (!flag) {}
        flag = 0;
        printf("signal received\n");
    }
}
```

Здесь цикл `while (!flag) {}` ждет, пока не будет установлена
глобальная переменная `flag`, а единственный вариант это сделать &mdash;
из обработчика сигнала. То есть, фактически этот цикл ждет
поступления сигнала. Если мы скомпилируем программу без оптимизаций
`gcc sig2.c -osig2`, то эта программа будет работать как ожидалось.
Но если включить оптимизацию, программа перестанет работать в том
смысле, что `printf` никогда не будет выполнятся. Получается, что оптимизация
"сломала" нашу программу, а правильнее говорить, что наша программа
оказалась в чем-то неправильна, что оптимизация ее поломала.

Если посмотреть на код, который сгенерировал компилятор gcc в
случае компиляции без оптимизаций, мы увидим следующий фрагмент:

```
.L3:
    movl    flag, %eax
    testl   %eax, %eax
    je  .L3
```

это вполне ожидаемо. Переменная `flag` считывается на регистр `eax`,
после чего проверяется на 0, и если она равна 0 выполняется
переход на начало цикла.

Но если посмотреть на код, сгенерированный gcc при включенных
оптимизациях, мы увидим следующее:

```
    movl    flag, %eax
    testl   %eax, %eax
    jne .L8
.L7:
    jmp .L7
.L8:
```

То есть выполняется однократная проверка переменной `flag`,
после чего программа входит в бесконечный цикл.
То есть компилятор выносит загрузку значения глобальной
переменной из памяти вовне цикла, а поскольку после этого
в цикле значение переменной не меняется, остается бесконечный
цикл. Компилятор имеет полное право так делать, поскольку
компилятор исходит из модели программы, которая выполняется
в один поток и полностью синхронно, то есть компилятор
не предполагает, что выполнение основной программы может быть
прервано и выполнение временно будет передано на другую функцию.

Поэтому компилятору нужно указать, что глобальная переменная
`flag` в этом смысле особенная и может измениться в любой
момент времени независимо от работы основной программы.
Для таких переменных компилятор не будет выполнять
оптимизацию считывания значения переменной из памяти.
Для указания свойства асинхронной изменяемости переменной
используется ключевое слово `volatile` языка Си.
Это ключевое слово необходимо добавить к объявлению
переменной как показано ниже.

```c
#include <signal.h>
#include <stdio.h>

volatile int flag;

void handler(int s)
{
    flag = 1;
}

int main()
{
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (1) {
        while (!flag) {}
        flag = 0;
        printf("signal received\n");
    }
}
```

Переменная `flag`, помимо того, что она должна быть `volatile`-переменной,
не может иметь произвольный тип. Операция записи значения
в переменную и операция чтения значения из памяти должна быть
атомарной процессорной инструкцией. Поэтому в заголовочном файле `<signal.h>`
определен тип `sig_atomic_t`, для которого гарантируется атомарность.
Вместо типа `int` следует использовать его:

```c
volatile sig_atomic_t flag;
```

На практике на всех современных 32- и 64-битных
процессорных архитектурах работа с правильно-выровненными значениями
типов `_Bool`, `char`, `int` и их беззнаковых вариантах атомарна.
Но вот типы `long long`, `double`, `long double` не будут атомарными
на 32-битных платформах и не должны использоваться для передачи информации
от обработчика сигнала основной программе.

### Проблема активного ожидания

В программе выше присутствует существенный недостаток.
Рассмотрим цикл ожидания прихода сигнала:

```c
        while (!flag) {}
```

Все время, пока программа ждет прихода сигнала, процессор
постоянно выполняет инструкции выборки значения из памяти,
проверки значения и условного перехода:

```
.L4:
    movl    flag, %eax
    testl   %eax, %eax
    je  .L4
```

То есть все время ожидания процессор выполняет эти три инструкции,
а соответствующий процесс постоянно находится в состоянии
Running. Это, во-первых, мешает работать другим процессам,
и, во-вторых, приводит к максимальному энергопотреблению
и как следствие максимальному нагреву процессора. По сути,
процессор не делает ничего полезного, только нагревает
окружающую среду и тратит электроэнергию, сажая аккумулятор
мобильного устройство.

Такой способ ожидания события называется "активное ожидание" (busy wait).
На уровне пользовательских процессов активное ожидание недопустимо!
Это &mdash; грубая ошибка программирования.
Активное ожидание иногда допустимо, но только на очень непродолжительное
время, не более нескольких микросекунд.

Вместо активного ожидания правильная программа должна перекладывать
задачу ожидания наступления события на ядро операционной системы
с помощью соответствующих системных вызовов. Ядро операционной
системы переведет процесс в состояние ожидания ('S' - Sleeping),
в котором процесс не будет занимать процессор бессмысленной работой.
Когда ожидаемое событие наступит, ядро разбудит спящий процесс
и переведет его в состояние выполнения.

Простейший системный вызов, который можно использовать для
ожидания сигнала &mdash; это `pause`. Системный вызов `pause`
блокирует выполнение процесса до прихода любого сигнала.
Программа с `pause` будет примерно такой:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

volatile sig_atomic_t flag;

void handler(int s)
{
    flag = 1;
}

int main()
{
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (1) {
        while (!flag) {
            pause();
        }
        flag = 0;
        printf("signal received\n");
    }
}
```

Мы избавились от активного ожидания в этой программе, но получили
другую ошибку &mdash; гонки (race condition).

### Проблема гонок (race condition)

Рассмотрим ключевой фрагмент программы выше:

```c
        while (!flag) {
            pause();
        }
        flag = 0;
```

он компилируется в такой фрагмент на ассемблере:

```
    movl    flag, %eax  // (1)
    testl   %eax, %eax
    jne .L8
.L5:
    call    pause       // (2) внутри этого вызова выполнятся системный вызов
    movl    flag, %eax
    testl   %eax, %eax
    je  .L5
.L8:
    movl    $0, flag    // (3)
```

Предположим, что сигнал был доставлен в процесс после
загрузки значения `flag` равного 0 в регистр `eax` (точка `(1)`),
но до выполнения инструкции системного вызова в точке `(2)`.
Между ними находятся порядка 10 инструкций процессора.
Как бы не быстро они выполнялись, поступление сигнала
в этом промежутке вполне возможно. Несмотря на то,
что сигнал в процесс был доставлен, процесс все равно
вызовет системный вызов `pause`, который приостановит
выполнение процесса до прихода следующего сигнала.
Поступление сигнала по сути потерялось потому что
сигнал поступил в процесс в тот момент, когда
процесс оказался "не готов" его принять.
Это типичная ситуация гонок.

Рассмотрим более сложный пример. Реализуем программу "пинг-понг"
в которой отец взаимодействует с сыном с помощью
единственного канала и сигнала `SIGUSR1`.
Отец записывает в канал начальное значение и
посылает сыну сигнал `SIGUSR1`. Сын считывает из канала
значение, выводит его, записывает в канал число на 1 большее,
отправляет родителю сигнал `SIGUSR1`, и так далее.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int fd[2];
int pid;

void handler(int s)
{
    int v;
    read(fd[0], &v, sizeof(v));
    printf("%d %d\n", getpid(), v); fflush(stdout);
    ++v;
    write(fd[1], &v, sizeof(v));
    kill(pid, SIGUSR1);
}

int main()
{
    pipe(fd);
    if (!(pid = fork())) {
        sigaction(SIGUSR1, &(struct sigaction){ .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
        pid = getppid();
        while (1) pause();
    } else {
        sigaction(SIGUSR1, &(struct sigaction){ .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
        {
            int v = 1;
            write(fd[1], &v, sizeof(v));
        }
        kill(pid, SIGUSR1);
        while (1) pause();
    }
}
```

Если запустим эту программу, он повиснет, не выведя ничего.
Если посмотреть на список процессов, мы увидем, что процесс-сын
завершился. Проблема в этой программе возникает из-за того,
что после `fork` отец и сын выполняются параллельно,
и, скорее всего (но не гарантированно), отец отправит
сыну сигнал до того, как сын успеет установить обработчик
сигнала `SIGUSR1`. Этот сигнал по умолчанию завершает процесс,
что мы и наблюдаем. Эта ошибка &mdash; тоже ситуация гонок.

Исправим ее, перенеся установку обработчка сигнала в точку
перед `fork`.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int fd[2];
int pid;

void handler(int s)
{
    int v;
    read(fd[0], &v, sizeof(v));
    printf("%d %d\n", getpid(), v); fflush(stdout);
    ++v;
    write(fd[1], &v, sizeof(v));
    kill(pid, SIGUSR1);
}

int main()
{
    pipe(fd);
    sigaction(SIGUSR1, &(struct sigaction){ .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    if (!(pid = fork())) {
        pid = getppid();
        while (1) pause();
    } else {
        {
            int v = 1;
            write(fd[1], &v, sizeof(v));
        }
        kill(pid, SIGUSR1);
        while (1) pause();
    }
}
```

Вполне возможно, что эта программа заработает как и ожидалось, то есть в
выводе будут чередоваться идентификаторы процессов, но вывод может быть
и примерно таким:

```
4874 1
4874 2
4874 3
4874 4
4874 5
```

Отец и сын имеют идентификаторы 4873, 4874. Получается, что
какое-то время выполняется только второй процесс, потом
они будут как-то странно чередоваться:

```
4874 537
4873 538
4873 539
4874 540
4874 541
```

То, что вывод программы от запуска к запуску может меняться
без каких-либо причин уже говорит о том, что в программе, скорее всего,
присутствуют гонки. Но причина гонок чуть более сложная.
Если мы распечатаем значение глобальной переменной `pid`
в обработчике сигнала, мы увидим, что в отце она равна, как и ожидалось,
`4874`, то есть идентификатору сына, а вот в сыне она равна `0`!
Отец отправляет сигнал только сыну по указанному pid, а вот сын
отправляет сигнал с аргументом 0 системного вызова `kill`,
то есть всем процессам текущей группы процессов, в которую
входит и отец, и сын. То есть сын отправляет сигнал и отцу,
и самому себе. Поскольку к моменту завершения обработчика
сигнала в сыне сын отправит себе тот же самый сигнал,
обработчик сигнала в сыне запустится вновь. То есть
процесс-сын никогда не вернется в основную программу
и никогда даже не дойдет до системного вызова `pause`.

Но почему переменная `pid` в сыне равна 0?
Процесс-сын начинает работу после `fork`,
еще находясь в режиме ядра, процессу-сыну нужно завершить
системный вызов в ядре, переключиться обратно в режим пользователя,
и уже в режиме пользователя завершить библиотечную функцию `fork`
(обертку над системным вызовом) и сохранить значение регистра `eax`
в глобальную переменную `pid`. Это может занять значительное
по меркам процессора время, за которое процесс-отец
может успеть отправить сыну сигнал `SIGUSR1`.
К моменту завершения системного вызова `fork` в сыне
сигнал `SIGUSR1` уже будет ожидать доставки, и выполнение
процесса-сына сразу переключится на обработчик сигнала.
Поэтому процесс-сын никогда даже не попадет в программу
после завершения вызова `fork`.

Данный конкретный race condition исправить достаточно просто.
Но в целом, как следует из рассмотренных примеров,
асинхронная обработка сигналов при неаккуратной реализации
может легко приводить к ошибкам гонок.

### Проблема слияния сигналов

Рассмотрим цикл из примера с ожиданием `SIGINT`.

```c
    while (1) {
        while (!flag) {
            pause();
        }
        flag = 0;
        printf("signal received\n"); fflush(stdout);
    }
```

Предположим, что за время, пока работает функция `printf`
успеет поступить несколько сигналов `SIGINT`. Например,
стандартный вывод перенаправлен в канал, который почти заполнен,
и системный вызов `write` заблокировался до освобождения места в
буфере канала. В этот момент в процесс несколько раз
поступил `SIGINT`. Обработчик сигнала был вызван несколько раз,
но поскольку он всего лишь устанавливает значение переменной в 1,
эффект будет такой же, как и единственный вызов функции-обработчика.
То есть, по сути, несколько получений сигнала превратилось в одно,
а остальные как бы потерялись.

Кажется, что эту проблему можно решить, используя переменную `flag`
не как булевский флаг, а как счетчик, увеличивая его значение
при каждом поступлении сигнала. Но на самом деле проблема более глубокая.
Как было рассмотренно выше, для стандартных сигналов поддерживается
множество (маска) сигналов, ожидающих доставки, где на каждый сигнал
отведен один бит. Очереди входящих стандартных сигналов не существует.
Поэтому, если сигналы будут поступать в процесс слишком быстро,
ядро операционной системы может просто не успеть выполнить отдельный
вызов обработчика сигнала на каждое его поступление. Обработчик сигнала
обязательно будет вызван, но возможно один раз на несколько поступлений
сигнала. Это принципиальная неустранимая особенность стандартных сигналов.

Поэтому сигналы можно использовать для сигнализации о смене состояния,
где, в общем, не важно, сколько раз его примет процесс, главное
чтобы он изменил свое состояние. Но в ситуациях, где требуется
передать какое-то значение, например, передать значение K
отправив сигнал K раз, сигналы использовать нельзя!

В принципе, такое поведение стандартных сигналов в точности
соответствует тому, как работают аппаратные прерывания.
Там тоже, если центральный процессор не успевает обработать
прерывания, они сливаются.

Частично проблема слияния сигналов решена для сигналов реального времени
`SIGRTMIN` ... `SIGRTMAX`. Для сигналов реального времени поддерживается
очередь сигналов. Каждый поступивший сигнал реального времени
ставится в очередь сигналов. Тем не менее, очередь сигналов
имеет ограниченный размер и для процесса и для пользователя,
и в случае переполнения очередь сигналы будут теряться.

### Проблема рестарта системных вызовов

Предположим, что мы хотим написать программу, которая
считывает данные со стандартного потока ввода, но если
нажата Ctrl-C программа печатает сообщение и завершается.

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <errno.h>

volatile sig_atomic_t flag;
void handler(int s)
{
    flag = 1;
}

int main()
{
    sigaction(SIGINT, &(struct sigaction){ .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);

    char buf[80];
    while (1) {
        int r = read(0, buf, sizeof(buf));
        if (flag) {
            printf("input canceled\n");
            break;
        }
        if (r < 0) {
            fprintf(stderr, "error: %s\n", strerror(errno));
            return 1;
        }
        if (!r) {
            break;
        }
        write(1, buf, r);
    }
}
```

Однако, программа не будет работать как ожидалось.
Если не вводить никаких данных на стандартном потоке ввода,
а просто нажать Ctrl-C, ничего не произойдет. Только после
того, как после нажатия Ctrl-C будут введены какие-то данные,
системный вызов `read` завершится, будет проверено
значение `flag` и программа отработает поступивший сигнал.

То есть, если процесс ожидал поступления данных в системном вызове
`read`, в процесс поступил сигнал, для которого был вызван
обработчик сигнала, который завершился, но не завершил процесс,
процесс вернется к ожиданию ввода в системном вызове `read`.
Системный вызов `read` завершится тогда, когда поступят данные.
Такое поведение системных вызовов и сигналов является более
удобным в большинстве случаев. И оно включается с помощью
опции `SA_RESTART` в флагах `sigaction`.

Если убрать опцию `SA_RESTART`, то системные вызовы
будут прерываться при приходе сигналов. Системный вызов `read`
в этом случае вернет значение -1, а в переменной `errno`
будет код ошибки `EINTR`. Если потребуется, системный
вызов `read` можно будет перезапустить вручную.

Итак, программу выше следует модифицировать следующим образом.

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <errno.h>

volatile sig_atomic_t flag;
void handler(int s)
{
    flag = 1;
}

int main()
{
    sigaction(SIGINT, &(struct sigaction){ .sa_handler = handler }, NULL);

    char buf[80];
    while (1) {
        int r = read(0, buf, sizeof(buf));
        if (r < 0 && errno == EINTR && flag) {
            printf("input canceled\n");
            break;
        }
        if (r < 0) {
            fprintf(stderr, "error: %s\n", strerror(errno));
            return 1;
        }
        if (!r) {
            break;
        }
        write(1, buf, r);
    }
}
```

`SA_RESTART` работает только для системных вызовов, основное назначение
которых &mdash; считать данные. Это системные вызовы `read`, `write`, `accept`
и аналогичные. На системные вызовы, основное назначение которых &mdash;
ожидать события, `SA_RESTART` не действует. К таким относятся системные
вызовы `wait`, `sleep`, `sigsuspend`, `pause` и аналогичные.

Если на момент поступления сигнала часть данных уже была записана
или прочитана, системный вызов будет завершен успешно, а операция
будет выполнена частично, то есть системные вызовы `read` или `write`
вернут размер, меньший размера переданного буфера.
Флаг `SA_RESTART` в этом случае не работает.

### Особенности сигналов-исключений

Сигналы-исключения типа `SIGFPE`, `SIGSEGV` и аналогичные
как правило генерируются синхронно ядром при возникновении
аппаратного исключения. С другой стороны, эти сигналы могут
использоваться как обычные асинхронные сигналы, посылаемые
одним процессом другому. Во втором случае работа с ними
не имеет никакой специфики, но в случае синхронной генерации
есть несколько особенностей, на которые следует обратить внимание.

```c
#include <stdio.h>
#include <signal.h>

int main()
{
    int a, b;
    signal(SIGFPE, SIG_IGN);
    while (scanf("%d%d", &a, &b) == 2) {
        printf("%d\n", a / b);
    }
}
```

Если отправить сигнал `SIGFPE` с помощью системного вызова `kill`,
сигнал `SIGFPE` будет проигнорирован, как и ожидалось.
Однако если на стандартном потоке ввода ввести `2 0`, и вызвать
таким образом исключение деления на 0, то сигнал будет
обработан в режиме по умолчанию, и работа процесса будет
аварийно завершена. Аналогичное поведение будет в случае
блокирования сигнала.

Стандарт утверждает, что поведение системы в случае, когда
возникает игнорируемый или блокируемый сигнал-исключение,
неопределено. Linux в этом случае обрабатывает сигналы
в режиме по умолчанию.

Рассмотрим пример с обработкой сигнала.

```c
#include <stdio.h>
#include <signal.h>

void handler(int s)
{
    printf("signal\n");
}

int main()
{
    int a, b;
    sigaction(SIGFPE, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (scanf("%d%d", &a, &b) == 2) {
        printf("%d\n", a / b);
    }
}
```

Если послать сигнал `SIGFPE` из другого процесса с помощью `kill`,
обработчик сигнала будет вызван один раз, как и ожидалось.
Однако если на стандартном потоке ввода ввести `2 0`, и вызвать
таким образом исключение деления на 0, то
программа зациклится и будет бесконечно вызывать обработчик сигнала.

Дело в том, что в случае обычного прерывания текущая инструкция процессора
дорабатывает до конца, и как точка возврата из прерывания
запоминается адрес следующей инструкции. Но в случае прерываний-исключений,
таких как исключение деления на ноль, или исключение page fault,
текущая инструкция не завершается, наоборот, все ее эффекты отменяются,
а в качестве адреса возврата из прерывания запоминается адрес
текущей инструкции. В результате после завершения обработчика
сигнала `SIGFPE` управление вернется в основную программу
снова на инструкцию деления, снова выполнится деление на 0,
и снова будет вызван обработчик сигнала.

Да, формально с точки зрения стандарта Си операция деления на 0 &mdash;
это undefined behavior, поэтому поведение программы в принципе может
быть любым, но мы здесь рассматриваем поведение, де-факто
реализованое в Linux на процессорах семейства x86. Эти детали
поведения программы могут быть в некоторых случаях полезны.

## Корректная обработка сигналов

Чтобы избежать большинства проблем, которые могут возникнуть
при обработке сигналов, следует использовать блокирование сигналов.
Процесс может заблокировать сигнал (кроме `SIGKILL` и `SIGSTOP`).
Когда сигнал поступит в процесс, он будет добавлен в множество
сигналов, ожидающих доставки, но доставлен не будет.
Сигнал может находиться во множестве сигналов, ожидающих доставки,
неограниченно долго либо до момента, когда он будет разблокирован,
тогда будет выполнена стандартная процедура его доставки,
либо до момента, когда он будет явным образом извлечен из
множества сигналов, ожидающих доставки, либо когда будет установлено
игнорирование сигнала, либо когда процесс завершится.

Одна из стратегий обработки сигналов в программе следующая.
Программа блокирует сигналы в самом начале работы, и основное
время работы программы блокировка сигналов будет включена.
Лишь только в тех местах программы, когда программа готова
принимать и обрабатывать сигналы, они разблокируется,
причем разблокировка выполняется, как правило, вместе с другими
действиями по вводу-выводу, например, в системных вызовах
`sigsuspend` или `epoll` или `ppoll`. Пока сигнал заблокирован,
если он поступил в программу, он будет помещен во множество сигналов,
ожидающих доставки. Несколько поступлений одного и того же сигнала
сольются в одно поступление. Как только сигналы будет разблокированы,
вызовутся их обработчики.

### Работа с множествами сигналов

Несколько множеств сигналов являются атрибутами процесса:
множество обрабатываемых сигналов, множество игнорируемых сигналов (ignored),
множество заблокированных сигналов (blocked) и множество сигналов,
ожидающих доставки (pending). Управлять ими можно с помощью
некоторых системных вызовов, требующих в качестве аргумента
множество сигналов. Хотя скорее всего в реализации множество сигналов
представлено как 64-битное значение, непосредственного доступа
к представлению множества сигналов программисту не предоставляется,
и программист работает со множеством сигналов с помощью функций.

Множество сигналов может содержать и сигналы `SIGKILL` и `SIGSTOP`,
только системные вызовы для этих сигналов не будут иметь эффекта.

```c
#include <signal.h>

int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);
```

Тип `sigset_t` &mdash; это тип для множества сигналов.
Работать с ним следует только с помощью перечисленных выше функций.

Функция `sigemptyset` очищает (обнуляет) множество сигналов.
Эту функцию необходимо использовать для начальной инициализации
локальной переменной типа `sigset_t`, так как по умолчанию
локальная переменная этого типа будет содержать "мусор".

Функция `sigfillset` полностью заполняет множество сигналов.

Функция `sigaddset` добавляет сигнал с номером `signum` в множество `set`.

Функция `sigdelset` удаляет сигнал с номером `signum` из множества `set`.

Функция `sigismember` возвращает истинное значение, если сигнал `signum`
находится во множестве `set`.

### Работа со множеством блокируемых сигналов

Получить текущее значение множества блокируемых сигналов или изменить
его можно с помощью системного вызова `sigprocmask`.

```c
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

Если указатель `oldset` не нулевой, по этому указателю будет
записано множество блокируемых сигналов на момент начала
работы `sigprocmask`, то есть старое множество блокируемых сигналов.
Если старое множество сохранять не требуется, следует передавать `NULL`.

Параметр `how` задает способ, которым множество `set` влияет
на текущее множество блокируемых сигналов.
Значение `SIG_BLOCK` означает, что множество сигналов `set`
добавляется во множество блокируемых сигналов.
Значение `SIG_UNBLOCK` означает, что множество сигналов `set`
удаляется из множества блокируемых сигналов.
Значение `SIG_SETMASK` означает, что множество сигналов `set`
копируется во множество блокируемых сигналов.

В параметре `set` могут быть установлены сигналы `SIGKILL` и `SIGSTOP`,
но это не будет иметь никакого эффекта. Эти сигналы не могут быть
заблокированы.

### Ожидание прихода сигнала

Ожидать прихода сигнала можно с помощью нескольких системных вызовов:
`sigsuspend`, `sigwaitinfo`, `sigtimedwait`, `pselect`, `ppoll`,
`epoll_wait`. Сначала мы рассмотрим самый простой из них &mdash;
`sigsuspend`.

```c
#include <signal.h>

int sigsuspend(const sigset_t *mask);
```

Системный вызов `sigsuspend` выполняет следующие действия:
* копирует множество блокируемых сигналов `mask` в множество блокируемых
сигналов процесса
* ждет прихода любого сигнала из незаблокированных. Если сигнал
обрабатывается по-умолчанию, то он будет обработан, и если процесс
не будет завершен после этого, ожидание продолжится.
Ожидание завершается когда приходит сигнал, который незаблокирован,
который обрабатывается пользовательским обработчиком,
и обработчик не завершил выполнение процесса.
* после завершения ожидания восстанавливается исходное множество
блокируемых сигналов процесса. То есть после завершения
системного вызова `sigsuspend` множество заблокированных сигналов
будет в том же состоянии, что до начала системного вызова.

Если необходимо ждать некоторого сигнала, то этот сигнал
не должен находится во временном множестве заблокированных сигналов!
Самый простой вариант &mdash; передать в `mask` пустое множество сигналов.

Первый пример, в котором программа ждет получения `SIGINT`
с использованием `sigsuspend` будет таким:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

volatile sig_atomic_t flag;

void handler(int s)
{
    flag = 1;
}

int main()
{
    sigset_t s1, s2;
    // формируем множество блокируемых сигналов из SIGINT
    sigemptyset(&s1); sigaddset(&s1, SIGINT);
    sigprocmask(SIG_BLOCK, &s1, NULL);
    // пустое множество временно блокируемых сигналов для sigsuspend
    sigemptyset(&s2);
    sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    while (1) {
        while (!flag) {
            // sigsuspend вместо pause
            sigsuspend(&s2);
        }
        flag = 0;
        printf("signal received\n");
    }
}
```

Аналогично может быть модифицирован пример с пинг-понгом между отцом
и сыном. Блокировку сигнала `SIGUSR1` можно выполнить в самом начале
программы в отце. При системном вызове `fork` множество заблокированных
сигналов будет унаследовано сыном, поэтому сын сразу начнет работу
с заблокированными сигналами. Таким образом, даже если отец и опередит
сына, послав сигнал до того, как сын выполнит настройку обработки сигнала,
сигнал `SIGUSR1` заблокируется до момента выполнения `sigsuspend`.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int fd[2];
int pid;

void handler(int s)
{
    int v;
    read(fd[0], &v, sizeof(v));
    printf("%d %d\n", getpid(), v); fflush(stdout);
    ++v;
    write(fd[1], &v, sizeof(v));
    kill(pid, SIGUSR1);
}

int main()
{
    sigset_t s1, s2;
    sigemptyset(&s1); sigaddset(&s1, SIGUSR1);
    sigprocmask(SIG_BLOCK, &s1, NULL);
    sigemptyset(&s2);

    pipe(fd);
    sigaction(SIGUSR1, &(struct sigaction){ .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    if (!(pid = fork())) {
        pid = getppid();
    } else {
        int v = 1;
        write(fd[1], &v, sizeof(v));
        kill(pid, SIGUSR1);
    }
    while (1) {
        sigsuspend(&s2);
    }
}
```

Более того, эту программу можно переписать так, что
обработчик сигнала только устанавливает флаг прихода сигнала,
а основная обработка выполняется в основной программе.
Это более универсально, так как не нужно думать
об асинхронной безопасности обработчика сигнала.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

volatile sig_atomic_t flag;
void handler(int s)
{
    flag = 1;
}

int main()
{
    int v;
    sigset_t s1, s2;
    sigemptyset(&s1); sigaddset(&s1, SIGUSR1);
    sigprocmask(SIG_BLOCK, &s1, NULL);
    sigemptyset(&s2);
    int fd[2];
    int pid;

    pipe(fd);
    sigaction(SIGUSR1, &(struct sigaction){ .sa_handler = handler, .sa_flags = SA_RESTART }, NULL);
    if (!(pid = fork())) {
        pid = getppid();
    } else {
        write(fd[1], &v, sizeof(v));
        kill(pid, SIGUSR1);
    }
    while (1) {
        while (!flag) {
            sigsuspend(&s2);
        }
        flag = 0;
        read(fd[0], &v, sizeof(v));
        printf("%d %d\n", getpid(), v); fflush(stdout);
        ++v;
        write(fd[1], &v, sizeof(v));
        kill(pid, SIGUSR1);
    }
}
```

### Сигналы как файловые дескрипторы

Если посмотреть на программу выше, легко заметить, что логика
программы с ожиданием сигналов в одном системном вызове `sigsuspend`
практически не отличается от логики, когда процесс ожидает с помощью
read на файловом дескрипторе. В самом деле, сигналы
мы можем заменить на пару каналов: один от отца к сыну, другой
от сына к отцу, в котором будем передавать не значение,
а разрешение на выполнение, как в случае использования каналов как
семафоров. Для ожидания разрешения на выполнение будет использоваться `read`.

Файловые дескрипторы и `read` удобны тем, что механизм файловых дескрипторов
предоставляет однотипный механизм ожидания события на самых разных устройствах.
Существуют системные вызовы (`pselect`, `ppoll`, `epoll_wait`),
которые позволяют проверять состояние нескольких дескрипторов
одновременно.

Поэтому операционная система Linux предлагает механизм signalfd,
который позволяет отображать операцию получения сигнала
на операцию чтения из файлового дескриптора.

Системный вызова `signalfd` позволяет создать специальный файловый
дескриптор для сигналов.

```c
#include <sys/signalfd.h>

int signalfd(int fd, const sigset_t *mask, int flags);
```

Если параметр `fd` равен -1, то создается новый файловый дескриптор.
В противном случае параметр `fd` должен быть равным файловому
дескриптору сигналов, созданному ранее. Параметр `mask` &mdash;
это множество сигналов, которые будут обрабатываться с
помощью этого файлового дескриптора. Эти сигналы должны быть
заблокированы, а иначе будет использоваться стандартный механизм
обработки сигналов. Параметр `flags` допускает использование
флагов `SFD_NONBLOCK`, `SFD_CLOEXEC`, аналогичных флагам `O_NONBLOCK`
и `O_CLOEXEC`.

В случае успешного выполнения `signalfd` мы получаем файловый
дескриптор, над которым можно выполнять операцию чтения.
Системный вызов `read` над этим дескриптором в обычном
(блокирующем) режиме заблокирует процесс до получения сигнала.
Когда сигнал поступит `read` заполнит переданную область памяти
информацией о поступившем сигнале. Передаваемая информация
определена в структуре `struct signalfd_siginfo`, поэтому блокирующее
чтение из файлового дескриптора может быть выполнена следующим образом:
```c
    struct signalfd_siginfo sinfo;
    if (read(fd, &sinfo, sizeof(sinfo)) != sizeof(sinfo)) {
        // что-то пошло совсем не так, мы сломали систему!
        abort();
    }
```

Структура `struct signalfd_siginfo` содержит много полей, в частности,
`ssi_signo` &mdash; номер сигнала, `ssi_pid` &mdash; идентификатор
процесса, отправившего сигнал.

В качестве примера рассмотрим следующую модификацию игры в пинг-понг.
Отец создает двух сыновей, а они по единственному каналу
начинают играть в пинг-понг, синхронизируясь с помощью
сигнала `SIGUSR1`, который отправляют друг другу.

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/signalfd.h>

void work(int rfd, int wfd)
{
    sigset_t ss;
    sigemptyset(&ss); sigaddset(&ss, SIGUSR1);
    int sfd = signalfd(-1, &ss, 0);
    while (1) {
        struct signalfd_siginfo sinfo;
        read(sfd, &sinfo, sizeof(sinfo));
        int v;
        read(rfd, &v, sizeof(v));
        printf("%d %d\n", getpid(), v);
        ++v;
        write(wfd, &v, sizeof(v));
        kill(sinfo.ssi_pid, SIGUSR1);
    }
}

int main()
{
    sigset_t ss;
    sigemptyset(&ss); sigaddset(&ss, SIGUSR1);
    sigprocmask(SIG_BLOCK, &ss, NULL);

    int fd[2];
    pipe(fd);
    int pid1 = fork();
    if (!pid1) {
        work(fd[0], fd[1]);
        _exit(0);
    }
    int pid2 = fork();
    if (!pid2) {
        int v = 1;
        write(fd[1], &v, sizeof(v));
        kill(pid1, SIGUSR1);
        work(fd[0], fd[1]);
        _exit(0);
    }
    while (wait(NULL) > 0) {}
}
```

Обратите внимание, что в функции `work` процесс отправляет ответный
сигнал процессу, от которого был получен сигнал. Это избавляет нас
от необходимости предварительно передавать идентификатор процесса
второго сына в первый сын.
